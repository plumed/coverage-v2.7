<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
<meta name="robots" content="noindex">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - plumed test coverage - opes/OPESmetad.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">opes</a> - OPESmetad.cpp<span style="font-size: 80%;"> (source / <a href="OPESmetad.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">plumed test coverage</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">756</td>
            <td class="headerCovTableEntry">798</td>
            <td class="headerCovTableEntryHi">94.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2023-04-27 21:36:50</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntryHi">94.4 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</a>
<a name="2"><span class="lineNum">       2 </span>            :    Copyright (c) 2020-2021 of Michele Invernizzi.</a>
<a name="3"><span class="lineNum">       3 </span>            : </a>
<a name="4"><span class="lineNum">       4 </span>            :    This file is part of the OPES plumed module.</a>
<a name="5"><span class="lineNum">       5 </span>            : </a>
<a name="6"><span class="lineNum">       6 </span>            :    The OPES plumed module is free software: you can redistribute it and/or modify</a>
<a name="7"><span class="lineNum">       7 </span>            :    it under the terms of the GNU Lesser General Public License as published by</a>
<a name="8"><span class="lineNum">       8 </span>            :    the Free Software Foundation, either version 3 of the License, or</a>
<a name="9"><span class="lineNum">       9 </span>            :    (at your option) any later version.</a>
<a name="10"><span class="lineNum">      10 </span>            : </a>
<a name="11"><span class="lineNum">      11 </span>            :    The OPES plumed module is distributed in the hope that it will be useful,</a>
<a name="12"><span class="lineNum">      12 </span>            :    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="13"><span class="lineNum">      13 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="14"><span class="lineNum">      14 </span>            :    GNU Lesser General Public License for more details.</a>
<a name="15"><span class="lineNum">      15 </span>            : </a>
<a name="16"><span class="lineNum">      16 </span>            :    You should have received a copy of the GNU Lesser General Public License</a>
<a name="17"><span class="lineNum">      17 </span>            :    along with plumed.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="18"><span class="lineNum">      18 </span>            : +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */</a>
<a name="19"><span class="lineNum">      19 </span>            : #include &quot;bias/Bias.h&quot;</a>
<a name="20"><span class="lineNum">      20 </span>            : #include &quot;core/PlumedMain.h&quot;</a>
<a name="21"><span class="lineNum">      21 </span>            : #include &quot;core/ActionRegister.h&quot;</a>
<a name="22"><span class="lineNum">      22 </span>            : #include &quot;core/Atoms.h&quot;</a>
<a name="23"><span class="lineNum">      23 </span>            : #include &quot;tools/Communicator.h&quot;</a>
<a name="24"><span class="lineNum">      24 </span>            : #include &quot;tools/File.h&quot;</a>
<a name="25"><span class="lineNum">      25 </span>            : #include &quot;tools/OpenMP.h&quot;</a>
<a name="26"><span class="lineNum">      26 </span>            : </a>
<a name="27"><span class="lineNum">      27 </span>            : namespace PLMD {</a>
<a name="28"><span class="lineNum">      28 </span>            : namespace opes {</a>
<a name="29"><span class="lineNum">      29 </span>            : </a>
<a name="30"><span class="lineNum">      30 </span>            : //+PLUMEDOC OPES_BIAS OPES_METAD</a>
<a name="31"><span class="lineNum">      31 </span>            : /*</a>
<a name="32"><span class="lineNum">      32 </span>            : On-the-fly probability enhanced sampling (OPES) with metadynamics-like target distribution \cite Invernizzi2020rethinking.</a>
<a name="33"><span class="lineNum">      33 </span>            : </a>
<a name="34"><span class="lineNum">      34 </span>            : The OPES method aims at sampling a given target distribution over the configuration space, \f$p^{\text{tg}}(\mathbf{x})\f$,</a>
<a name="35"><span class="lineNum">      35 </span>            : different from the equilibrium Boltzmann distribution, \f$P(\mathbf{x})\propto e^{-\beta U(\mathbf{x})}\f$.</a>
<a name="36"><span class="lineNum">      36 </span>            : To do so, it incrementally builds a bias potential \f$V(\mathbf{x})\f$, by estimating on-the-fly the needed probability distributions:</a>
<a name="37"><span class="lineNum">      37 </span>            : \f[</a>
<a name="38"><span class="lineNum">      38 </span>            : V(\mathbf{x}) = -\frac{1}{\beta}\log\frac{p^{\text{tg}}(\mathbf{x})}{P(\mathbf{x})}\, .</a>
<a name="39"><span class="lineNum">      39 </span>            : \f]</a>
<a name="40"><span class="lineNum">      40 </span>            : The bias quickly becomes quasi-static and the desired properties, such as the free energy, can be calculated with a simple reweighting \ref REWEIGHT_BIAS.</a>
<a name="41"><span class="lineNum">      41 </span>            : </a>
<a name="42"><span class="lineNum">      42 </span>            : This OPES_METAD action samples target distributions defined via their marginal \f$p^{\text{tg}}(\mathbf{s})\f$ over some collective variables (CVs), \f$\mathbf{s}=\mathbf{s}(\mathbf{x})\f$.</a>
<a name="43"><span class="lineNum">      43 </span>            : By default OPES_METAD targets the well-tempered distribution, \f$p^{\text{tg}}(\mathbf{s})\propto [P(\mathbf{s})]^{1/\gamma}\f$, where \f$\gamma\f$ is known as BIASFACTOR.</a>
<a name="44"><span class="lineNum">      44 </span>            : Similarly to \ref METAD, OPES_METAD optimizes the bias on-the-fly, with a given PACE.</a>
<a name="45"><span class="lineNum">      45 </span>            : It does so by reweighting via kernel density estimation the unbiased distribution in the CV space, \f$P(\mathbf{s})\f$.</a>
<a name="46"><span class="lineNum">      46 </span>            : A compression algorithm is used to prevent the number of kernels from growing linearly with the simulation time.</a>
<a name="47"><span class="lineNum">      47 </span>            : See Ref.\cite Invernizzi2020rethinking for a complete description of the method.</a>
<a name="48"><span class="lineNum">      48 </span>            : </a>
<a name="49"><span class="lineNum">      49 </span>            : As an intuitive picture, rather than gradually filling the metastable basins, OPES_METAD quickly tries to get a coarse idea of the full free energy surface (FES), and then slowly refines its details.</a>
<a name="50"><span class="lineNum">      50 </span>            : It has a fast initial exploration phase, and then becomes extremely conservative and does not significantly change the shape of the deposited bias any more, reaching a regime of quasi-static bias.</a>
<a name="51"><span class="lineNum">      51 </span>            : For this reason, it is possible to use standard umbrella sampling reweighting (see \ref REWEIGHT_BIAS) to analyse the trajectory.</a>
<a name="52"><span class="lineNum">      52 </span>            : At &lt;a href=&quot;https://github.com/invemichele/opes/tree/master/postprocessing&quot;&gt;this link&lt;/a&gt; you can find some python scripts that work in a similar way to \ref sum_hills, but the preferred way to obtain a FES with OPES is via reweighting (see \ref opes-metad).</a>
<a name="53"><span class="lineNum">      53 </span>            : The estimated \f$c(t)\f$ is printed for reference only, since it should converge to a fixed value as the bias converges.</a>
<a name="54"><span class="lineNum">      54 </span>            : This \f$c(t)\f$ should NOT be used for reweighting.</a>
<a name="55"><span class="lineNum">      55 </span>            : Similarly, the \f$Z_n\f$ factor is printed only for reference, and it should converge when no new region of the CV-space is explored.</a>
<a name="56"><span class="lineNum">      56 </span>            : </a>
<a name="57"><span class="lineNum">      57 </span>            : Notice that OPES_METAD is more sensitive to degenerate CVs than \ref METAD.</a>
<a name="58"><span class="lineNum">      58 </span>            : If the employed CVs map different metastable basins onto the same CV-space region, then OPES_METAD will remain stuck rather than completely reshaping the bias.</a>
<a name="59"><span class="lineNum">      59 </span>            : This can be useful to diagnose problems with your collective variable.</a>
<a name="60"><span class="lineNum">      60 </span>            : If it is not possible to improve the set of CVs and remove this degeneracy, then you might instead consider to use \ref METAD with a high BIASFACTOR, or even without well-tempering.</a>
<a name="61"><span class="lineNum">      61 </span>            : In this way you will be able to obtain an estimate of the FES, but be aware that you most likely will not reach convergence and thus this estimate will be subjected to systematic errors (see e.g. Fig.3 in \cite Pietrucci2017review).</a>
<a name="62"><span class="lineNum">      62 </span>            : On the contrary, if your CVs are not degenerate but only suboptimal, you should converge faster by using OPES_METAD instead of \ref METAD \cite Invernizzi2020rethinking.</a>
<a name="63"><span class="lineNum">      63 </span>            : </a>
<a name="64"><span class="lineNum">      64 </span>            : The parameter BARRIER should be set to be at least equal to the highest free energy barrier you wish to overcome.</a>
<a name="65"><span class="lineNum">      65 </span>            : If it is much lower than that, you will not cross the barrier, if it is much higher, convergence might take a little longer.</a>
<a name="66"><span class="lineNum">      66 </span>            : If the system has a basin that is clearly more stable than the others, it is better to start the simulation from there.</a>
<a name="67"><span class="lineNum">      67 </span>            : </a>
<a name="68"><span class="lineNum">      68 </span>            : By default, the kernels SIGMA is adaptive, estimated from the fluctuations over ADAPTIVE_SIGMA_STRIDE simulation steps (similar to \ref METAD ADAPTIVE=DIFF, but contrary to that, no artifacts are introduced and the bias will converge to the correct one).</a>
<a name="69"><span class="lineNum">      69 </span>            : However, notice that depending on the system this might not be the optimal choice for SIGMA.</a>
<a name="70"><span class="lineNum">      70 </span>            : </a>
<a name="71"><span class="lineNum">      71 </span>            : You can target a uniform flat distribution by explicitly setting BIASFACTOR=inf.</a>
<a name="72"><span class="lineNum">      72 </span>            : However, this should be useful only in very specific cases.</a>
<a name="73"><span class="lineNum">      73 </span>            : </a>
<a name="74"><span class="lineNum">      74 </span>            : Restart can be done from a KERNELS file, but it might not be perfect (due to limited precision when printing kernels to file, or usage of adaptive SIGMA).</a>
<a name="75"><span class="lineNum">      75 </span>            : For an exact restart you must use STATE_RFILE to read a checkpoint with all the needed info.</a>
<a name="76"><span class="lineNum">      76 </span>            : To save such checkpoints, define a STATE_WFILE and choose how often to print them with STATE_WSTRIDE.</a>
<a name="77"><span class="lineNum">      77 </span>            : By default this file is overwritten, but you can instead append to it using the flag STORE_STATES.</a>
<a name="78"><span class="lineNum">      78 </span>            : </a>
<a name="79"><span class="lineNum">      79 </span>            : Multiple walkers are supported only with MPI communication, via the keyword WALKERS_MPI.</a>
<a name="80"><span class="lineNum">      80 </span>            : </a>
<a name="81"><span class="lineNum">      81 </span>            : \par Examples</a>
<a name="82"><span class="lineNum">      82 </span>            : </a>
<a name="83"><span class="lineNum">      83 </span>            : Several examples can be found on the &lt;a href=&quot;https://www.plumed-nest.org/browse.html&quot;&gt;PLUMED-NEST website&lt;/a&gt;, by searching for the OPES keyword.</a>
<a name="84"><span class="lineNum">      84 </span>            : The following \ref opes-metad can also be useful to get started with the method.</a>
<a name="85"><span class="lineNum">      85 </span>            : </a>
<a name="86"><span class="lineNum">      86 </span>            : The following is a minimal working example:</a>
<a name="87"><span class="lineNum">      87 </span>            : </a>
<a name="88"><span class="lineNum">      88 </span>            : \plumedfile</a>
<a name="89"><span class="lineNum">      89 </span>            : cv: DISTANCE ATOMS=1,2</a>
<a name="90"><span class="lineNum">      90 </span>            : opes: OPES_METAD ARG=cv PACE=200 BARRIER=40</a>
<a name="91"><span class="lineNum">      91 </span>            : PRINT STRIDE=200 FILE=COLVAR ARG=*</a>
<a name="92"><span class="lineNum">      92 </span>            : \endplumedfile</a>
<a name="93"><span class="lineNum">      93 </span>            : </a>
<a name="94"><span class="lineNum">      94 </span>            : Another more articulated one:</a>
<a name="95"><span class="lineNum">      95 </span>            : </a>
<a name="96"><span class="lineNum">      96 </span>            : \plumedfile</a>
<a name="97"><span class="lineNum">      97 </span>            : phi: TORSION ATOMS=5,7,9,15</a>
<a name="98"><span class="lineNum">      98 </span>            : psi: TORSION ATOMS=7,9,15,17</a>
<a name="99"><span class="lineNum">      99 </span>            : </a>
<a name="100"><span class="lineNum">     100 </span>            : opes: OPES_METAD ...</a>
<a name="101"><span class="lineNum">     101 </span>            :   FILE=Kernels.data</a>
<a name="102"><span class="lineNum">     102 </span>            :   TEMP=300</a>
<a name="103"><span class="lineNum">     103 </span>            :   ARG=phi,psi</a>
<a name="104"><span class="lineNum">     104 </span>            :   SIGMA=0.15,0.15</a>
<a name="105"><span class="lineNum">     105 </span>            :   PACE=500</a>
<a name="106"><span class="lineNum">     106 </span>            :   BARRIER=50</a>
<a name="107"><span class="lineNum">     107 </span>            :   BIASFACTOR=inf</a>
<a name="108"><span class="lineNum">     108 </span>            :   STATE_RFILE=Restart.data</a>
<a name="109"><span class="lineNum">     109 </span>            :   STATE_WFILE=State.data</a>
<a name="110"><span class="lineNum">     110 </span>            :   STATE_WSTRIDE=500*100</a>
<a name="111"><span class="lineNum">     111 </span>            :   STORE_STATES</a>
<a name="112"><span class="lineNum">     112 </span>            :   WALKERS_MPI</a>
<a name="113"><span class="lineNum">     113 </span>            :   NLIST</a>
<a name="114"><span class="lineNum">     114 </span>            : ...</a>
<a name="115"><span class="lineNum">     115 </span>            : </a>
<a name="116"><span class="lineNum">     116 </span>            : PRINT FMT=%g STRIDE=500 FILE=Colvar.data ARG=phi,psi,opes.*</a>
<a name="117"><span class="lineNum">     117 </span>            : \endplumedfile</a>
<a name="118"><span class="lineNum">     118 </span>            : </a>
<a name="119"><span class="lineNum">     119 </span>            : </a>
<a name="120"><span class="lineNum">     120 </span>            : */</a>
<a name="121"><span class="lineNum">     121 </span>            : //+ENDPLUMEDOC</a>
<a name="122"><span class="lineNum">     122 </span>            : </a>
<a name="123"><span class="lineNum">     123 </span>            : class OPESmetad : public bias::Bias {</a>
<a name="124"><span class="lineNum">     124 </span>            : </a>
<a name="125"><span class="lineNum">     125 </span>            : private:</a>
<a name="126"><span class="lineNum">     126 </span>            :   bool isFirstStep_;</a>
<a name="127"><span class="lineNum">     127 </span>            :   bool afterCalculate_;</a>
<a name="128"><span class="lineNum">     128 </span>            :   unsigned NumOMP_;</a>
<a name="129"><span class="lineNum">     129 </span>            :   unsigned NumParallel_;</a>
<a name="130"><span class="lineNum">     130 </span>            :   unsigned rank_;</a>
<a name="131"><span class="lineNum">     131 </span>            :   unsigned NumWalkers_;</a>
<a name="132"><span class="lineNum">     132 </span>            :   unsigned walker_rank_;</a>
<a name="133"><span class="lineNum">     133 </span>            :   unsigned long counter_;</a>
<a name="134"><span class="lineNum">     134 </span>            :   std::size_t ncv_;</a>
<a name="135"><span class="lineNum">     135 </span>            : </a>
<a name="136"><span class="lineNum">     136 </span>            :   double kbt_;</a>
<a name="137"><span class="lineNum">     137 </span>            :   double biasfactor_;</a>
<a name="138"><span class="lineNum">     138 </span>            :   double bias_prefactor_;</a>
<a name="139"><span class="lineNum">     139 </span>            :   unsigned stride_;</a>
<a name="140"><span class="lineNum">     140 </span>            :   std::vector&lt;double&gt; sigma0_;</a>
<a name="141"><span class="lineNum">     141 </span>            :   std::vector&lt;double&gt; sigma_min_;</a>
<a name="142"><span class="lineNum">     142 </span>            :   unsigned adaptive_sigma_stride_;</a>
<a name="143"><span class="lineNum">     143 </span>            :   unsigned long adaptive_counter_;</a>
<a name="144"><span class="lineNum">     144 </span>            :   std::vector&lt;double&gt; av_cv_;</a>
<a name="145"><span class="lineNum">     145 </span>            :   std::vector&lt;double&gt; av_M2_;</a>
<a name="146"><span class="lineNum">     146 </span>            :   bool fixed_sigma_;</a>
<a name="147"><span class="lineNum">     147 </span>            :   bool adaptive_sigma_;</a>
<a name="148"><span class="lineNum">     148 </span>            :   double epsilon_;</a>
<a name="149"><span class="lineNum">     149 </span>            :   double sum_weights_;</a>
<a name="150"><span class="lineNum">     150 </span>            :   double sum_weights2_;</a>
<a name="151"><span class="lineNum">     151 </span>            :   double current_bias_;</a>
<a name="152"><span class="lineNum">     152 </span>            : </a>
<a name="153"><span class="lineNum">     153 </span>            :   bool no_Zed_;</a>
<a name="154"><span class="lineNum">     154 </span>            :   double Zed_;</a>
<a name="155"><span class="lineNum">     155 </span>            :   double KDEnorm_;</a>
<a name="156"><span class="lineNum">     156 </span>            : </a>
<a name="157"><span class="lineNum">     157 </span>            :   double threshold2_;</a>
<a name="158"><span class="lineNum">     158 </span>            :   bool recursive_merge_;</a>
<a name="159"><span class="lineNum">     159 </span>            : //kernels are truncated diagonal Gaussians</a>
<a name="160"><span class="lineNum">     160 </span><span class="lineCov">        470 :   struct kernel</span></a>
<a name="161"><span class="lineNum">     161 </span>            :   {</a>
<a name="162"><span class="lineNum">     162 </span>            :     double height;</a>
<a name="163"><span class="lineNum">     163 </span>            :     std::vector&lt;double&gt; center;</a>
<a name="164"><span class="lineNum">     164 </span>            :     std::vector&lt;double&gt; sigma;</a>
<a name="165"><span class="lineNum">     165 </span><span class="lineCov">        792 :     kernel(double h, const std::vector&lt;double&gt;&amp; c,const std::vector&lt;double&gt;&amp; s):</span></a>
<a name="166"><span class="lineNum">     166 </span><span class="lineCov">        792 :       height(h),center(c),sigma(s) {}</span></a>
<a name="167"><span class="lineNum">     167 </span>            :   };</a>
<a name="168"><span class="lineNum">     168 </span>            :   double cutoff2_;</a>
<a name="169"><span class="lineNum">     169 </span>            :   double val_at_cutoff_;</a>
<a name="170"><span class="lineNum">     170 </span>            :   void mergeKernels(kernel&amp;,const kernel&amp;); //merge the second one into the first one</a>
<a name="171"><span class="lineNum">     171 </span>            :   double evaluateKernel(const kernel&amp;,const std::vector&lt;double&gt;&amp;) const;</a>
<a name="172"><span class="lineNum">     172 </span>            :   double evaluateKernel(const kernel&amp;,const std::vector&lt;double&gt;&amp;,std::vector&lt;double&gt;&amp;,std::vector&lt;double&gt;&amp;);</a>
<a name="173"><span class="lineNum">     173 </span>            :   std::vector&lt;kernel&gt; kernels_; //all compressed kernels</a>
<a name="174"><span class="lineNum">     174 </span>            :   OFile kernelsOfile_;</a>
<a name="175"><span class="lineNum">     175 </span>            : //neighbour list stuff</a>
<a name="176"><span class="lineNum">     176 </span>            :   bool nlist_;</a>
<a name="177"><span class="lineNum">     177 </span>            :   double nlist_param_[2];</a>
<a name="178"><span class="lineNum">     178 </span>            :   std::vector&lt;unsigned&gt; nlist_index_;</a>
<a name="179"><span class="lineNum">     179 </span>            :   std::vector&lt;double&gt; nlist_center_;</a>
<a name="180"><span class="lineNum">     180 </span>            :   std::vector&lt;double&gt; nlist_dev2_;</a>
<a name="181"><span class="lineNum">     181 </span>            :   unsigned nlist_steps_;</a>
<a name="182"><span class="lineNum">     182 </span>            :   bool nlist_update_;</a>
<a name="183"><span class="lineNum">     183 </span>            :   bool nlist_pace_reset_;</a>
<a name="184"><span class="lineNum">     184 </span>            : </a>
<a name="185"><span class="lineNum">     185 </span>            :   bool calc_work_;</a>
<a name="186"><span class="lineNum">     186 </span>            :   double work_;</a>
<a name="187"><span class="lineNum">     187 </span>            :   double old_KDEnorm_;</a>
<a name="188"><span class="lineNum">     188 </span>            :   std::vector&lt;kernel&gt; delta_kernels_;</a>
<a name="189"><span class="lineNum">     189 </span>            : </a>
<a name="190"><span class="lineNum">     190 </span>            :   OFile stateOfile_;</a>
<a name="191"><span class="lineNum">     191 </span>            :   int wStateStride_;</a>
<a name="192"><span class="lineNum">     192 </span>            :   bool storeOldStates_;</a>
<a name="193"><span class="lineNum">     193 </span>            : </a>
<a name="194"><span class="lineNum">     194 </span>            :   double getProbAndDerivatives(const std::vector&lt;double&gt;&amp;,std::vector&lt;double&gt;&amp;);</a>
<a name="195"><span class="lineNum">     195 </span>            :   void addKernel(const double,const std::vector&lt;double&gt;&amp;,const std::vector&lt;double&gt;&amp;);</a>
<a name="196"><span class="lineNum">     196 </span>            :   void addKernel(const double,const std::vector&lt;double&gt;&amp;,const std::vector&lt;double&gt;&amp;,const double); //also print to file</a>
<a name="197"><span class="lineNum">     197 </span>            :   unsigned getMergeableKernel(const std::vector&lt;double&gt;&amp;,const unsigned);</a>
<a name="198"><span class="lineNum">     198 </span>            :   void updateNlist(const std::vector&lt;double&gt;&amp;);</a>
<a name="199"><span class="lineNum">     199 </span>            :   void dumpStateToFile();</a>
<a name="200"><span class="lineNum">     200 </span>            : </a>
<a name="201"><span class="lineNum">     201 </span>            : public:</a>
<a name="202"><span class="lineNum">     202 </span>            :   explicit OPESmetad(const ActionOptions&amp;);</a>
<a name="203"><span class="lineNum">     203 </span>            :   void calculate() override;</a>
<a name="204"><span class="lineNum">     204 </span>            :   void update() override;</a>
<a name="205"><span class="lineNum">     205 </span>            :   static void registerKeywords(Keywords&amp; keys);</a>
<a name="206"><span class="lineNum">     206 </span>            : };</a>
<a name="207"><span class="lineNum">     207 </span>            : </a>
<a name="208"><span class="lineNum">     208 </span><span class="lineCov">       6567 : PLUMED_REGISTER_ACTION(OPESmetad,&quot;OPES_METAD&quot;)</span></a>
<a name="209"><span class="lineNum">     209 </span>            : </a>
<a name="210"><span class="lineNum">     210 </span><span class="lineCov">         13 : void OPESmetad::registerKeywords(Keywords&amp; keys)</span></a>
<a name="211"><span class="lineNum">     211 </span>            : {</a>
<a name="212"><span class="lineNum">     212 </span><span class="lineCov">         13 :   Bias::registerKeywords(keys);</span></a>
<a name="213"><span class="lineNum">     213 </span><span class="lineCov">         13 :   keys.use(&quot;ARG&quot;);</span></a>
<a name="214"><span class="lineNum">     214 </span><span class="lineCov">         26 :   keys.add(&quot;compulsory&quot;,&quot;TEMP&quot;,&quot;-1&quot;,&quot;temperature. If not set, it is taken from MD engine, but not all MD codes provide it&quot;);</span></a>
<a name="215"><span class="lineNum">     215 </span><span class="lineCov">         26 :   keys.add(&quot;compulsory&quot;,&quot;PACE&quot;,&quot;the frequency for kernel deposition&quot;);</span></a>
<a name="216"><span class="lineNum">     216 </span><span class="lineCov">         26 :   keys.add(&quot;compulsory&quot;,&quot;SIGMA&quot;,&quot;ADAPTIVE&quot;,&quot;the initial widths of the kernels. If not set, adaptive sigma will be used and the ADAPTIVE_SIGMA_STRIDE should be set&quot;);</span></a>
<a name="217"><span class="lineNum">     217 </span><span class="lineCov">         26 :   keys.add(&quot;compulsory&quot;,&quot;BARRIER&quot;,&quot;the free energy barrier to be overcome. It is used to set BIASFACTOR, EPSILON, and KERNEL_CUTOFF to reasonable values&quot;);</span></a>
<a name="218"><span class="lineNum">     218 </span><span class="lineCov">         39 :   keys.add(&quot;compulsory&quot;,&quot;COMPRESSION_THRESHOLD&quot;,&quot;1&quot;,&quot;merge kernels if closer than this threshold, in units of sigma&quot;);</span></a>
<a name="219"><span class="lineNum">     219 </span>            : //extra options</a>
<a name="220"><span class="lineNum">     220 </span><span class="lineCov">         39 :   keys.add(&quot;optional&quot;,&quot;ADAPTIVE_SIGMA_STRIDE&quot;,&quot;number of steps for measuring adaptive sigma. Default is 10xPACE&quot;);</span></a>
<a name="221"><span class="lineNum">     221 </span><span class="lineCov">         26 :   keys.add(&quot;optional&quot;,&quot;SIGMA_MIN&quot;,&quot;never reduce SIGMA below this value&quot;);</span></a>
<a name="222"><span class="lineNum">     222 </span><span class="lineCov">         26 :   keys.add(&quot;optional&quot;,&quot;BIASFACTOR&quot;,&quot;the \\f$\\gamma\\f$ bias factor used for the well-tempered target \\f$p(\\mathbf{s})\\f$. Set to 'inf' for uniform flat target&quot;);</span></a>
<a name="223"><span class="lineNum">     223 </span><span class="lineCov">         26 :   keys.add(&quot;optional&quot;,&quot;EPSILON&quot;,&quot;the value of the regularization constant for the probability&quot;);</span></a>
<a name="224"><span class="lineNum">     224 </span><span class="lineCov">         26 :   keys.add(&quot;optional&quot;,&quot;KERNEL_CUTOFF&quot;,&quot;truncate kernels at this distance, in units of sigma&quot;);</span></a>
<a name="225"><span class="lineNum">     225 </span><span class="lineCov">         39 :   keys.add(&quot;optional&quot;,&quot;NLIST_PARAMETERS&quot;,&quot;( default=3.0,0.5 ) the two cutoff parameters for the kernels neighbor list&quot;);</span></a>
<a name="226"><span class="lineNum">     226 </span><span class="lineCov">         26 :   keys.addFlag(&quot;NLIST&quot;,false,&quot;use neighbor list for kernels summation, faster but experimental&quot;);</span></a>
<a name="227"><span class="lineNum">     227 </span><span class="lineCov">         26 :   keys.addFlag(&quot;NLIST_PACE_RESET&quot;,false,&quot;force the reset of the neighbor list at each PACE. Can be useful with WALKERS_MPI&quot;);</span></a>
<a name="228"><span class="lineNum">     228 </span><span class="lineCov">         26 :   keys.addFlag(&quot;FIXED_SIGMA&quot;,false,&quot;do not decrease sigma as simulation goes on. Can be added in a RESTART, to keep in check the number of compressed kernels&quot;);</span></a>
<a name="229"><span class="lineNum">     229 </span><span class="lineCov">         26 :   keys.addFlag(&quot;RECURSIVE_MERGE_OFF&quot;,false,&quot;do not recursively attempt kernel merging when a new one is added&quot;);</span></a>
<a name="230"><span class="lineNum">     230 </span><span class="lineCov">         26 :   keys.addFlag(&quot;NO_ZED&quot;,false,&quot;do not normalize over the explored CV space, \\f$Z_n=1\\f$&quot;);</span></a>
<a name="231"><span class="lineNum">     231 </span>            : //kernels and state files</a>
<a name="232"><span class="lineNum">     232 </span><span class="lineCov">         26 :   keys.add(&quot;compulsory&quot;,&quot;FILE&quot;,&quot;KERNELS&quot;,&quot;a file in which the list of all deposited kernels is stored&quot;);</span></a>
<a name="233"><span class="lineNum">     233 </span><span class="lineCov">         26 :   keys.add(&quot;optional&quot;,&quot;FMT&quot;,&quot;specify format for KERNELS file&quot;);</span></a>
<a name="234"><span class="lineNum">     234 </span><span class="lineCov">         26 :   keys.add(&quot;optional&quot;,&quot;STATE_RFILE&quot;,&quot;read from this file the compressed kernels and all the info needed to RESTART the simulation&quot;);</span></a>
<a name="235"><span class="lineNum">     235 </span><span class="lineCov">         26 :   keys.add(&quot;optional&quot;,&quot;STATE_WFILE&quot;,&quot;write to this file the compressed kernels and all the info needed to RESTART the simulation&quot;);</span></a>
<a name="236"><span class="lineNum">     236 </span><span class="lineCov">         26 :   keys.add(&quot;optional&quot;,&quot;STATE_WSTRIDE&quot;,&quot;number of MD steps between writing the STATE_WFILE. Default is only on CPT events (but not all MD codes set them)&quot;);</span></a>
<a name="237"><span class="lineNum">     237 </span><span class="lineCov">         26 :   keys.addFlag(&quot;STORE_STATES&quot;,false,&quot;append to STATE_WFILE instead of ovewriting it each time&quot;);</span></a>
<a name="238"><span class="lineNum">     238 </span>            : //miscellaneous</a>
<a name="239"><span class="lineNum">     239 </span><span class="lineCov">         26 :   keys.addFlag(&quot;CALC_WORK&quot;,false,&quot;calculate the total accumulated work done by the bias since last restart&quot;);</span></a>
<a name="240"><span class="lineNum">     240 </span><span class="lineCov">         26 :   keys.addFlag(&quot;WALKERS_MPI&quot;,false,&quot;switch on MPI version of multiple walkers&quot;);</span></a>
<a name="241"><span class="lineNum">     241 </span><span class="lineCov">         26 :   keys.addFlag(&quot;SERIAL&quot;,false,&quot;perform calculations in serial&quot;);</span></a>
<a name="242"><span class="lineNum">     242 </span><span class="lineCov">         13 :   keys.use(&quot;RESTART&quot;);</span></a>
<a name="243"><span class="lineNum">     243 </span><span class="lineCov">         13 :   keys.use(&quot;UPDATE_FROM&quot;);</span></a>
<a name="244"><span class="lineNum">     244 </span><span class="lineCov">         13 :   keys.use(&quot;UPDATE_UNTIL&quot;);</span></a>
<a name="245"><span class="lineNum">     245 </span>            : </a>
<a name="246"><span class="lineNum">     246 </span>            : //output components</a>
<a name="247"><span class="lineNum">     247 </span><span class="lineCov">         26 :   keys.addOutputComponent(&quot;rct&quot;,&quot;default&quot;,&quot;estimate of \\f$c(t)\\f$: \\f$\\frac{1}{\\beta}\\log \\langle e^{\\beta V} \\rangle\\f$, should become flat as the simulation converges. Do NOT use for reweighting&quot;);</span></a>
<a name="248"><span class="lineNum">     248 </span><span class="lineCov">         26 :   keys.addOutputComponent(&quot;zed&quot;,&quot;default&quot;,&quot;estimate of \\f$Z_n\\f$, should become flat as no new CV-space region is explored&quot;);</span></a>
<a name="249"><span class="lineNum">     249 </span><span class="lineCov">         26 :   keys.addOutputComponent(&quot;neff&quot;,&quot;default&quot;,&quot;effective sample size&quot;);</span></a>
<a name="250"><span class="lineNum">     250 </span><span class="lineCov">         26 :   keys.addOutputComponent(&quot;nker&quot;,&quot;default&quot;,&quot;total number of compressed kernels used to represent the bias&quot;);</span></a>
<a name="251"><span class="lineNum">     251 </span><span class="lineCov">         26 :   keys.addOutputComponent(&quot;work&quot;,&quot;CALC_WORK&quot;,&quot;total accumulated work done by the bias&quot;);</span></a>
<a name="252"><span class="lineNum">     252 </span><span class="lineCov">         26 :   keys.addOutputComponent(&quot;nlker&quot;,&quot;NLIST&quot;,&quot;number of kernels in the neighbor list&quot;);</span></a>
<a name="253"><span class="lineNum">     253 </span><span class="lineCov">         26 :   keys.addOutputComponent(&quot;nlsteps&quot;,&quot;NLIST&quot;,&quot;number of steps from last neighbor list update&quot;);</span></a>
<a name="254"><span class="lineNum">     254 </span><span class="lineCov">         13 : }</span></a>
<a name="255"><span class="lineNum">     255 </span>            : </a>
<a name="256"><span class="lineNum">     256 </span><span class="lineCov">         12 : OPESmetad::OPESmetad(const ActionOptions&amp; ao)</span></a>
<a name="257"><span class="lineNum">     257 </span>            :   : PLUMED_BIAS_INIT(ao)</a>
<a name="258"><span class="lineNum">     258 </span>            :   , isFirstStep_(true)</a>
<a name="259"><span class="lineNum">     259 </span>            :   , afterCalculate_(false)</a>
<a name="260"><span class="lineNum">     260 </span>            :   , counter_(1)</a>
<a name="261"><span class="lineNum">     261 </span><span class="lineCov">         12 :   , ncv_(getNumberOfArguments())</span></a>
<a name="262"><span class="lineNum">     262 </span>            :   , Zed_(1)</a>
<a name="263"><span class="lineNum">     263 </span><span class="lineCov">         12 :   , work_(0)</span></a>
<a name="264"><span class="lineNum">     264 </span>            : {</a>
<a name="265"><span class="lineNum">     265 </span><span class="lineCov">         24 :   std::string error_in_input1(&quot;Error in input in action &quot;+getName()+&quot; with label &quot;+getLabel()+&quot;: the keyword &quot;);</span></a>
<a name="266"><span class="lineNum">     266 </span><span class="lineCov">         12 :   std::string error_in_input2(&quot; could not be read correctly&quot;);</span></a>
<a name="267"><span class="lineNum">     267 </span>            : </a>
<a name="268"><span class="lineNum">     268 </span>            : //set kbt_</a>
<a name="269"><span class="lineNum">     269 </span><span class="lineCov">         12 :   const double Kb=plumed.getAtoms().getKBoltzmann();</span></a>
<a name="270"><span class="lineNum">     270 </span><span class="lineCov">         12 :   kbt_=plumed.getAtoms().getKbT();</span></a>
<a name="271"><span class="lineNum">     271 </span><span class="lineCov">         12 :   double temp=-1;</span></a>
<a name="272"><span class="lineNum">     272 </span><span class="lineCov">         12 :   parse(&quot;TEMP&quot;,temp);</span></a>
<a name="273"><span class="lineNum">     273 </span><span class="lineCov">         12 :   if(temp&gt;0)</span></a>
<a name="274"><span class="lineNum">     274 </span>            :   {</a>
<a name="275"><span class="lineNum">     275 </span><span class="lineCov">         12 :     if(kbt_&gt;0 &amp;&amp; std::abs(kbt_-Kb*temp)&gt;1e-4)</span></a>
<a name="276"><span class="lineNum">     276 </span><span class="lineNoCov">          0 :       log.printf(&quot; +++ WARNING +++ using TEMP=%g while MD engine uses %g\n&quot;,temp,kbt_/Kb);</span></a>
<a name="277"><span class="lineNum">     277 </span><span class="lineCov">         12 :     kbt_=Kb*temp;</span></a>
<a name="278"><span class="lineNum">     278 </span>            :   }</a>
<a name="279"><span class="lineNum">     279 </span><span class="lineCov">         12 :   plumed_massert(kbt_&gt;0,&quot;your MD engine does not pass the temperature to plumed, you must specify it using TEMP&quot;);</span></a>
<a name="280"><span class="lineNum">     280 </span>            : </a>
<a name="281"><span class="lineNum">     281 </span>            : //other compulsory input</a>
<a name="282"><span class="lineNum">     282 </span><span class="lineCov">         12 :   parse(&quot;PACE&quot;,stride_);</span></a>
<a name="283"><span class="lineNum">     283 </span>            : </a>
<a name="284"><span class="lineNum">     284 </span><span class="lineCov">         12 :   double barrier=0;</span></a>
<a name="285"><span class="lineNum">     285 </span><span class="lineCov">         12 :   parse(&quot;BARRIER&quot;,barrier);</span></a>
<a name="286"><span class="lineNum">     286 </span><span class="lineCov">         12 :   plumed_massert(barrier&gt;=0,&quot;the BARRIER should be greater than zero&quot;);</span></a>
<a name="287"><span class="lineNum">     287 </span>            : </a>
<a name="288"><span class="lineNum">     288 </span><span class="lineCov">         12 :   biasfactor_=barrier/kbt_;</span></a>
<a name="289"><span class="lineNum">     289 </span>            :   std::string biasfactor_str;</a>
<a name="290"><span class="lineNum">     290 </span><span class="lineCov">         24 :   parse(&quot;BIASFACTOR&quot;,biasfactor_str);</span></a>
<a name="291"><span class="lineNum">     291 </span><span class="lineCov">         20 :   if(biasfactor_str==&quot;inf&quot; || biasfactor_str==&quot;INF&quot;)</span></a>
<a name="292"><span class="lineNum">     292 </span>            :   {</a>
<a name="293"><span class="lineNum">     293 </span><span class="lineCov">          4 :     biasfactor_=std::numeric_limits&lt;double&gt;::infinity();</span></a>
<a name="294"><span class="lineNum">     294 </span><span class="lineCov">          4 :     bias_prefactor_=1;</span></a>
<a name="295"><span class="lineNum">     295 </span>            :   }</a>
<a name="296"><span class="lineNum">     296 </span>            :   else</a>
<a name="297"><span class="lineNum">     297 </span>            :   {</a>
<a name="298"><span class="lineNum">     298 </span><span class="lineCov">          8 :     if(biasfactor_str.length()&gt;0)</span></a>
<a name="299"><span class="lineNum">     299 </span><span class="lineNoCov">          0 :       plumed_massert(Tools::convert(biasfactor_str,biasfactor_),error_in_input1+&quot;BIASFACTOR&quot;+error_in_input2);</span></a>
<a name="300"><span class="lineNum">     300 </span><span class="lineCov">          8 :     plumed_massert(biasfactor_&gt;1,&quot;BIASFACTOR must be greater than one (use 'inf' for uniform target)&quot;);</span></a>
<a name="301"><span class="lineNum">     301 </span><span class="lineCov">          8 :     bias_prefactor_=1-1./biasfactor_;</span></a>
<a name="302"><span class="lineNum">     302 </span>            :   }</a>
<a name="303"><span class="lineNum">     303 </span>            : </a>
<a name="304"><span class="lineNum">     304 </span><span class="lineCov">         12 :   adaptive_sigma_=false;</span></a>
<a name="305"><span class="lineNum">     305 </span><span class="lineCov">         12 :   adaptive_sigma_stride_=0;</span></a>
<a name="306"><span class="lineNum">     306 </span><span class="lineCov">         24 :   parse(&quot;ADAPTIVE_SIGMA_STRIDE&quot;,adaptive_sigma_stride_);</span></a>
<a name="307"><span class="lineNum">     307 </span><span class="lineCov">         12 :   std::vector&lt;std::string&gt; sigma_str;</span></a>
<a name="308"><span class="lineNum">     308 </span><span class="lineCov">         12 :   parseVector(&quot;SIGMA&quot;,sigma_str);</span></a>
<a name="309"><span class="lineNum">     309 </span><span class="lineCov">         12 :   sigma0_.resize(ncv_);</span></a>
<a name="310"><span class="lineNum">     310 </span>            :   double dummy;</a>
<a name="311"><span class="lineNum">     311 </span><span class="lineCov">         12 :   if(sigma_str.size()==1 &amp;&amp; !Tools::convert(sigma_str[0],dummy))</span></a>
<a name="312"><span class="lineNum">     312 </span>            :   {</a>
<a name="313"><span class="lineNum">     313 </span><span class="lineCov">          6 :     plumed_massert(sigma_str[0]==&quot;ADAPTIVE&quot; || sigma_str[0]==&quot;adaptive&quot;,error_in_input1+&quot;SIGMA&quot;+error_in_input2);</span></a>
<a name="314"><span class="lineNum">     314 </span><span class="lineCov">          6 :     plumed_massert(!std::isinf(biasfactor_),&quot;cannot use BIASFACTOR=inf with adaptive SIGMA&quot;);</span></a>
<a name="315"><span class="lineNum">     315 </span><span class="lineCov">          6 :     adaptive_counter_=0;</span></a>
<a name="316"><span class="lineNum">     316 </span><span class="lineCov">          6 :     if(adaptive_sigma_stride_==0)</span></a>
<a name="317"><span class="lineNum">     317 </span><span class="lineCov">          2 :       adaptive_sigma_stride_=10*stride_; //NB: this is arbitrary, chosen from few tests</span></a>
<a name="318"><span class="lineNum">     318 </span><span class="lineCov">          6 :     av_cv_.resize(ncv_,0);</span></a>
<a name="319"><span class="lineNum">     319 </span><span class="lineCov">          6 :     av_M2_.resize(ncv_,0);</span></a>
<a name="320"><span class="lineNum">     320 </span><span class="lineCov">          6 :     plumed_massert(adaptive_sigma_stride_&gt;=stride_,&quot;better to chose ADAPTIVE_SIGMA_STRIDE &gt; PACE&quot;);</span></a>
<a name="321"><span class="lineNum">     321 </span><span class="lineCov">          6 :     adaptive_sigma_=true;</span></a>
<a name="322"><span class="lineNum">     322 </span>            :   }</a>
<a name="323"><span class="lineNum">     323 </span>            :   else</a>
<a name="324"><span class="lineNum">     324 </span>            :   {</a>
<a name="325"><span class="lineNum">     325 </span><span class="lineCov">          6 :     plumed_massert(sigma_str.size()==ncv_,&quot;number of SIGMA parameters does not match number of arguments&quot;);</span></a>
<a name="326"><span class="lineNum">     326 </span><span class="lineCov">          6 :     plumed_massert(adaptive_sigma_stride_==0,&quot;if SIGMA is not ADAPTIVE you cannot set an ADAPTIVE_SIGMA_STRIDE&quot;);</span></a>
<a name="327"><span class="lineNum">     327 </span><span class="lineCov">         18 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="328"><span class="lineNum">     328 </span>            :     {</a>
<a name="329"><span class="lineNum">     329 </span><span class="lineCov">         12 :       plumed_massert(Tools::convert(sigma_str[i],sigma0_[i]),error_in_input1+&quot;SIGMA&quot;+error_in_input2);</span></a>
<a name="330"><span class="lineNum">     330 </span>            :     }</a>
<a name="331"><span class="lineNum">     331 </span>            :   }</a>
<a name="332"><span class="lineNum">     332 </span><span class="lineCov">         24 :   parseVector(&quot;SIGMA_MIN&quot;,sigma_min_);</span></a>
<a name="333"><span class="lineNum">     333 </span><span class="lineCov">         12 :   plumed_massert(sigma_min_.size()==0 || sigma_min_.size()==ncv_,&quot;number of SIGMA_MIN does not match number of arguments&quot;);</span></a>
<a name="334"><span class="lineNum">     334 </span><span class="lineCov">         12 :   if(sigma_min_.size()&gt;0 &amp;&amp; !adaptive_sigma_)</span></a>
<a name="335"><span class="lineNum">     335 </span>            :   {</a>
<a name="336"><span class="lineNum">     336 </span><span class="lineNoCov">          0 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="337"><span class="lineNum">     337 </span><span class="lineNoCov">          0 :       plumed_massert(sigma_min_[i]&lt;=sigma0_[i],&quot;SIGMA_MIN should be smaller than SIGMA&quot;);</span></a>
<a name="338"><span class="lineNum">     338 </span>            :   }</a>
<a name="339"><span class="lineNum">     339 </span>            : </a>
<a name="340"><span class="lineNum">     340 </span><span class="lineCov">         12 :   epsilon_=std::exp(-barrier/bias_prefactor_/kbt_);</span></a>
<a name="341"><span class="lineNum">     341 </span><span class="lineCov">         12 :   parse(&quot;EPSILON&quot;,epsilon_);</span></a>
<a name="342"><span class="lineNum">     342 </span><span class="lineCov">         12 :   plumed_massert(epsilon_&gt;0,&quot;you must choose a value for EPSILON greater than zero. Is your BARRIER too high?&quot;);</span></a>
<a name="343"><span class="lineNum">     343 </span><span class="lineCov">         12 :   sum_weights_=std::pow(epsilon_,bias_prefactor_); //to avoid NANs we start with counter_=1 and w0=exp(beta*V0)</span></a>
<a name="344"><span class="lineNum">     344 </span><span class="lineCov">         12 :   sum_weights2_=sum_weights_*sum_weights_;</span></a>
<a name="345"><span class="lineNum">     345 </span>            : </a>
<a name="346"><span class="lineNum">     346 </span><span class="lineCov">         12 :   double cutoff=sqrt(2.*barrier/bias_prefactor_/kbt_);</span></a>
<a name="347"><span class="lineNum">     347 </span><span class="lineCov">         12 :   parse(&quot;KERNEL_CUTOFF&quot;,cutoff);</span></a>
<a name="348"><span class="lineNum">     348 </span><span class="lineCov">         12 :   plumed_massert(cutoff&gt;0,&quot;you must choose a value for KERNEL_CUTOFF greater than zero&quot;);</span></a>
<a name="349"><span class="lineNum">     349 </span><span class="lineCov">         12 :   cutoff2_=cutoff*cutoff;</span></a>
<a name="350"><span class="lineNum">     350 </span><span class="lineCov">         12 :   val_at_cutoff_=std::exp(-0.5*cutoff2_);</span></a>
<a name="351"><span class="lineNum">     351 </span>            : </a>
<a name="352"><span class="lineNum">     352 </span><span class="lineCov">         12 :   threshold2_=1;</span></a>
<a name="353"><span class="lineNum">     353 </span><span class="lineCov">         12 :   parse(&quot;COMPRESSION_THRESHOLD&quot;,threshold2_);</span></a>
<a name="354"><span class="lineNum">     354 </span><span class="lineCov">         12 :   threshold2_*=threshold2_;</span></a>
<a name="355"><span class="lineNum">     355 </span><span class="lineCov">         12 :   if(threshold2_!=0)</span></a>
<a name="356"><span class="lineNum">     356 </span><span class="lineCov">         12 :     plumed_massert(threshold2_&gt;0 &amp;&amp; threshold2_&lt;cutoff2_,&quot;COMPRESSION_THRESHOLD cannot be bigger than the KERNEL_CUTOFF&quot;);</span></a>
<a name="357"><span class="lineNum">     357 </span>            : </a>
<a name="358"><span class="lineNum">     358 </span>            : //setup neighbor list</a>
<a name="359"><span class="lineNum">     359 </span><span class="lineCov">         12 :   nlist_=false;</span></a>
<a name="360"><span class="lineNum">     360 </span><span class="lineCov">         12 :   parseFlag(&quot;NLIST&quot;,nlist_);</span></a>
<a name="361"><span class="lineNum">     361 </span><span class="lineCov">         12 :   nlist_pace_reset_=false;</span></a>
<a name="362"><span class="lineNum">     362 </span><span class="lineCov">         12 :   parseFlag(&quot;NLIST_PACE_RESET&quot;,nlist_pace_reset_);</span></a>
<a name="363"><span class="lineNum">     363 </span><span class="lineCov">         12 :   if(nlist_pace_reset_)</span></a>
<a name="364"><span class="lineNum">     364 </span><span class="lineCov">          2 :     nlist_=true;</span></a>
<a name="365"><span class="lineNum">     365 </span>            :   std::vector&lt;double&gt; nlist_param;</a>
<a name="366"><span class="lineNum">     366 </span><span class="lineCov">         24 :   parseVector(&quot;NLIST_PARAMETERS&quot;,nlist_param);</span></a>
<a name="367"><span class="lineNum">     367 </span><span class="lineCov">         12 :   if(nlist_param.size()==0)</span></a>
<a name="368"><span class="lineNum">     368 </span>            :   {</a>
<a name="369"><span class="lineNum">     369 </span><span class="lineCov">          8 :     nlist_param_[0]=3.0;//*cutoff2_ -&gt; max distance of neighbors</span></a>
<a name="370"><span class="lineNum">     370 </span><span class="lineCov">          8 :     nlist_param_[1]=0.5;//*nlist_dev2_[i] -&gt; condition for rebuilding</span></a>
<a name="371"><span class="lineNum">     371 </span>            :   }</a>
<a name="372"><span class="lineNum">     372 </span>            :   else</a>
<a name="373"><span class="lineNum">     373 </span>            :   {</a>
<a name="374"><span class="lineNum">     374 </span><span class="lineCov">          4 :     nlist_=true;</span></a>
<a name="375"><span class="lineNum">     375 </span><span class="lineCov">          4 :     plumed_massert(nlist_param.size()==2,&quot;two cutoff parameters are needed for the neighbor list&quot;);</span></a>
<a name="376"><span class="lineNum">     376 </span><span class="lineCov">          4 :     plumed_massert(nlist_param[0]&gt;1.0,&quot;the first of NLIST_PARAMETERS must be greater than 1. The smaller the first, the smaller should be the second as well&quot;);</span></a>
<a name="377"><span class="lineNum">     377 </span><span class="lineCov">          4 :     const double min_PARAM_1=(1.-1./std::sqrt(nlist_param[0]))+0.16;</span></a>
<a name="378"><span class="lineNum">     378 </span><span class="lineCov">          4 :     plumed_massert(nlist_param[1]&gt;0,&quot;the second of NLIST_PARAMETERS must be greater than 0&quot;);</span></a>
<a name="379"><span class="lineNum">     379 </span><span class="lineCov">          4 :     plumed_massert(nlist_param[1]&lt;=min_PARAM_1,&quot;the second of NLIST_PARAMETERS must be smaller to avoid systematic errors. Largest suggested value is: 1.16-1/sqrt(PARAM_0) = &quot;+std::to_string(min_PARAM_1));</span></a>
<a name="380"><span class="lineNum">     380 </span><span class="lineCov">          4 :     nlist_param_[0]=nlist_param[0];</span></a>
<a name="381"><span class="lineNum">     381 </span><span class="lineCov">          4 :     nlist_param_[1]=nlist_param[1];</span></a>
<a name="382"><span class="lineNum">     382 </span>            :   }</a>
<a name="383"><span class="lineNum">     383 </span><span class="lineCov">         12 :   nlist_center_.resize(ncv_);</span></a>
<a name="384"><span class="lineNum">     384 </span><span class="lineCov">         12 :   nlist_dev2_.resize(ncv_,0.);</span></a>
<a name="385"><span class="lineNum">     385 </span><span class="lineCov">         12 :   nlist_steps_=0;</span></a>
<a name="386"><span class="lineNum">     386 </span><span class="lineCov">         12 :   nlist_update_=true;</span></a>
<a name="387"><span class="lineNum">     387 </span>            : </a>
<a name="388"><span class="lineNum">     388 </span>            : //optional stuff</a>
<a name="389"><span class="lineNum">     389 </span><span class="lineCov">         12 :   no_Zed_=false;</span></a>
<a name="390"><span class="lineNum">     390 </span><span class="lineCov">         12 :   parseFlag(&quot;NO_ZED&quot;,no_Zed_);</span></a>
<a name="391"><span class="lineNum">     391 </span><span class="lineCov">         12 :   if(no_Zed_)</span></a>
<a name="392"><span class="lineNum">     392 </span>            :   { //this makes it more gentle in the initial phase</a>
<a name="393"><span class="lineNum">     393 </span><span class="lineCov">          4 :     sum_weights_=1;</span></a>
<a name="394"><span class="lineNum">     394 </span><span class="lineCov">          4 :     sum_weights2_=1;</span></a>
<a name="395"><span class="lineNum">     395 </span>            :   }</a>
<a name="396"><span class="lineNum">     396 </span><span class="lineCov">         12 :   fixed_sigma_=false;</span></a>
<a name="397"><span class="lineNum">     397 </span><span class="lineCov">         12 :   parseFlag(&quot;FIXED_SIGMA&quot;,fixed_sigma_);</span></a>
<a name="398"><span class="lineNum">     398 </span><span class="lineCov">         12 :   bool recursive_merge_off=false;</span></a>
<a name="399"><span class="lineNum">     399 </span><span class="lineCov">         12 :   parseFlag(&quot;RECURSIVE_MERGE_OFF&quot;,recursive_merge_off);</span></a>
<a name="400"><span class="lineNum">     400 </span><span class="lineCov">         12 :   recursive_merge_=!recursive_merge_off;</span></a>
<a name="401"><span class="lineNum">     401 </span><span class="lineCov">         24 :   parseFlag(&quot;CALC_WORK&quot;,calc_work_);</span></a>
<a name="402"><span class="lineNum">     402 </span>            : </a>
<a name="403"><span class="lineNum">     403 </span>            : //kernels file</a>
<a name="404"><span class="lineNum">     404 </span>            :   std::string kernelsFileName;</a>
<a name="405"><span class="lineNum">     405 </span><span class="lineCov">         24 :   parse(&quot;FILE&quot;,kernelsFileName);</span></a>
<a name="406"><span class="lineNum">     406 </span>            :   std::string fmt;</a>
<a name="407"><span class="lineNum">     407 </span><span class="lineCov">         24 :   parse(&quot;FMT&quot;,fmt);</span></a>
<a name="408"><span class="lineNum">     408 </span>            : </a>
<a name="409"><span class="lineNum">     409 </span>            : //output checkpoint of current state</a>
<a name="410"><span class="lineNum">     410 </span>            :   std::string restartFileName;</a>
<a name="411"><span class="lineNum">     411 </span><span class="lineCov">         24 :   parse(&quot;STATE_RFILE&quot;,restartFileName);</span></a>
<a name="412"><span class="lineNum">     412 </span>            :   std::string stateFileName;</a>
<a name="413"><span class="lineNum">     413 </span><span class="lineCov">         12 :   parse(&quot;STATE_WFILE&quot;,stateFileName);</span></a>
<a name="414"><span class="lineNum">     414 </span><span class="lineCov">         12 :   wStateStride_=0;</span></a>
<a name="415"><span class="lineNum">     415 </span><span class="lineCov">         12 :   parse(&quot;STATE_WSTRIDE&quot;,wStateStride_);</span></a>
<a name="416"><span class="lineNum">     416 </span><span class="lineCov">         12 :   storeOldStates_=false;</span></a>
<a name="417"><span class="lineNum">     417 </span><span class="lineCov">         12 :   parseFlag(&quot;STORE_STATES&quot;,storeOldStates_);</span></a>
<a name="418"><span class="lineNum">     418 </span><span class="lineCov">         12 :   if(wStateStride_!=0 || storeOldStates_)</span></a>
<a name="419"><span class="lineNum">     419 </span><span class="lineCov">          6 :     plumed_massert(stateFileName.length()&gt;0,&quot;filename for storing simulation status not specified, use STATE_WFILE&quot;);</span></a>
<a name="420"><span class="lineNum">     420 </span><span class="lineCov">         12 :   if(wStateStride_&gt;0)</span></a>
<a name="421"><span class="lineNum">     421 </span><span class="lineCov">          6 :     plumed_massert(wStateStride_&gt;=stride_,&quot;STATE_WSTRIDE is in units of MD steps, thus it is suggested to use a multiple of PACE&quot;);</span></a>
<a name="422"><span class="lineNum">     422 </span><span class="lineCov">         12 :   if(stateFileName.length()&gt;0 &amp;&amp; wStateStride_==0)</span></a>
<a name="423"><span class="lineNum">     423 </span><span class="lineNoCov">          0 :     wStateStride_=-1;//will print only on CPT events (checkpoints set by some MD engines, like gromacs)</span></a>
<a name="424"><span class="lineNum">     424 </span>            : </a>
<a name="425"><span class="lineNum">     425 </span>            : //multiple walkers //TODO implement also external mw for cp2k</a>
<a name="426"><span class="lineNum">     426 </span><span class="lineCov">         12 :   bool walkers_mpi=false;</span></a>
<a name="427"><span class="lineNum">     427 </span><span class="lineCov">         12 :   parseFlag(&quot;WALKERS_MPI&quot;,walkers_mpi);</span></a>
<a name="428"><span class="lineNum">     428 </span><span class="lineCov">         12 :   if(walkers_mpi)</span></a>
<a name="429"><span class="lineNum">     429 </span>            :   {</a>
<a name="430"><span class="lineNum">     430 </span><span class="lineCov">          6 :     if(comm.Get_rank()==0)//multi_sim_comm works on first rank only</span></a>
<a name="431"><span class="lineNum">     431 </span>            :     {</a>
<a name="432"><span class="lineNum">     432 </span><span class="lineCov">          6 :       NumWalkers_=multi_sim_comm.Get_size();</span></a>
<a name="433"><span class="lineNum">     433 </span><span class="lineCov">          6 :       walker_rank_=multi_sim_comm.Get_rank();</span></a>
<a name="434"><span class="lineNum">     434 </span>            :     }</a>
<a name="435"><span class="lineNum">     435 </span><span class="lineCov">          6 :     comm.Bcast(NumWalkers_,0); //if each walker has more than one processor update them all</span></a>
<a name="436"><span class="lineNum">     436 </span><span class="lineCov">          6 :     comm.Bcast(walker_rank_,0);</span></a>
<a name="437"><span class="lineNum">     437 </span>            :   }</a>
<a name="438"><span class="lineNum">     438 </span>            :   else</a>
<a name="439"><span class="lineNum">     439 </span>            :   {</a>
<a name="440"><span class="lineNum">     440 </span><span class="lineCov">          6 :     NumWalkers_=1;</span></a>
<a name="441"><span class="lineNum">     441 </span><span class="lineCov">          6 :     walker_rank_=0;</span></a>
<a name="442"><span class="lineNum">     442 </span>            :   }</a>
<a name="443"><span class="lineNum">     443 </span>            : </a>
<a name="444"><span class="lineNum">     444 </span>            : //parallelization stuff</a>
<a name="445"><span class="lineNum">     445 </span><span class="lineCov">         12 :   NumOMP_=OpenMP::getNumThreads();</span></a>
<a name="446"><span class="lineNum">     446 </span><span class="lineCov">         12 :   NumParallel_=comm.Get_size();</span></a>
<a name="447"><span class="lineNum">     447 </span><span class="lineCov">         12 :   rank_=comm.Get_rank();</span></a>
<a name="448"><span class="lineNum">     448 </span><span class="lineCov">         12 :   bool serial=false;</span></a>
<a name="449"><span class="lineNum">     449 </span><span class="lineCov">         12 :   parseFlag(&quot;SERIAL&quot;,serial);</span></a>
<a name="450"><span class="lineNum">     450 </span><span class="lineCov">         12 :   if(serial)</span></a>
<a name="451"><span class="lineNum">     451 </span>            :   {</a>
<a name="452"><span class="lineNum">     452 </span><span class="lineCov">          4 :     NumOMP_=1;</span></a>
<a name="453"><span class="lineNum">     453 </span><span class="lineCov">          4 :     NumParallel_=1;</span></a>
<a name="454"><span class="lineNum">     454 </span><span class="lineCov">          4 :     rank_=0;</span></a>
<a name="455"><span class="lineNum">     455 </span>            :   }</a>
<a name="456"><span class="lineNum">     456 </span>            : </a>
<a name="457"><span class="lineNum">     457 </span><span class="lineCov">         12 :   checkRead();</span></a>
<a name="458"><span class="lineNum">     458 </span>            : </a>
<a name="459"><span class="lineNum">     459 </span>            : //restart if needed</a>
<a name="460"><span class="lineNum">     460 </span>            :   bool convertKernelsToState=false;</a>
<a name="461"><span class="lineNum">     461 </span><span class="lineCov">         12 :   if(getRestart())</span></a>
<a name="462"><span class="lineNum">     462 </span>            :   {</a>
<a name="463"><span class="lineNum">     463 </span>            :     bool stateRestart=true;</a>
<a name="464"><span class="lineNum">     464 </span><span class="lineCov">         10 :     if(restartFileName.length()==0)</span></a>
<a name="465"><span class="lineNum">     465 </span>            :     {</a>
<a name="466"><span class="lineNum">     466 </span>            :       stateRestart=false;</a>
<a name="467"><span class="lineNum">     467 </span>            :       restartFileName=kernelsFileName;</a>
<a name="468"><span class="lineNum">     468 </span>            :     }</a>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">         20 :     IFile ifile;</span></a>
<a name="470"><span class="lineNum">     470 </span><span class="lineCov">         10 :     ifile.link(*this);</span></a>
<a name="471"><span class="lineNum">     471 </span><span class="lineCov">         10 :     if(ifile.FileExist(restartFileName))</span></a>
<a name="472"><span class="lineNum">     472 </span>            :     {</a>
<a name="473"><span class="lineNum">     473 </span><span class="lineCov">          8 :       bool tmp_nlist=nlist_;</span></a>
<a name="474"><span class="lineNum">     474 </span><span class="lineCov">          8 :       nlist_=false; // NLIST is not needed while restarting</span></a>
<a name="475"><span class="lineNum">     475 </span><span class="lineCov">          8 :       ifile.open(restartFileName);</span></a>
<a name="476"><span class="lineNum">     476 </span><span class="lineCov">          8 :       log.printf(&quot;  RESTART - make sure all used options are compatible\n&quot;);</span></a>
<a name="477"><span class="lineNum">     477 </span><span class="lineCov">          8 :       log.printf(&quot;    restarting from: %s\n&quot;,restartFileName.c_str());</span></a>
<a name="478"><span class="lineNum">     478 </span><span class="lineNoCov">          0 :       std::string action_name=getName();</span></a>
<a name="479"><span class="lineNum">     479 </span><span class="lineCov">          8 :       if(stateRestart)</span></a>
<a name="480"><span class="lineNum">     480 </span>            :       {</a>
<a name="481"><span class="lineNum">     481 </span><span class="lineCov">          4 :         log.printf(&quot;    it should be a STATE file (not a KERNELS file)\n&quot;);</span></a>
<a name="482"><span class="lineNum">     482 </span>            :         action_name+=&quot;_state&quot;;</a>
<a name="483"><span class="lineNum">     483 </span>            :       }</a>
<a name="484"><span class="lineNum">     484 </span>            :       else</a>
<a name="485"><span class="lineNum">     485 </span>            :       {</a>
<a name="486"><span class="lineNum">     486 </span><span class="lineCov">          4 :         log.printf(&quot; +++ WARNING +++ RESTART from KERNELS might be approximate, use STATE_WFILE and STATE_RFILE to restart from the exact state\n&quot;);</span></a>
<a name="487"><span class="lineNum">     487 </span>            :         action_name+=&quot;_kernels&quot;;</a>
<a name="488"><span class="lineNum">     488 </span>            :       }</a>
<a name="489"><span class="lineNum">     489 </span>            :       std::string old_action_name;</a>
<a name="490"><span class="lineNum">     490 </span><span class="lineCov">          8 :       ifile.scanField(&quot;action&quot;,old_action_name);</span></a>
<a name="491"><span class="lineNum">     491 </span><span class="lineCov">          8 :       plumed_massert(action_name==old_action_name,&quot;RESTART - mismatch between old and new action name. Expected '&quot;+action_name+&quot;', but found '&quot;+old_action_name+&quot;'&quot;);</span></a>
<a name="492"><span class="lineNum">     492 </span>            :       std::string old_biasfactor_str;</a>
<a name="493"><span class="lineNum">     493 </span><span class="lineCov">         16 :       ifile.scanField(&quot;biasfactor&quot;,old_biasfactor_str);</span></a>
<a name="494"><span class="lineNum">     494 </span><span class="lineCov">         14 :       if(old_biasfactor_str==&quot;inf&quot; || old_biasfactor_str==&quot;INF&quot;)</span></a>
<a name="495"><span class="lineNum">     495 </span>            :       {</a>
<a name="496"><span class="lineNum">     496 </span><span class="lineCov">          2 :         if(!std::isinf(biasfactor_))</span></a>
<a name="497"><span class="lineNum">     497 </span><span class="lineNoCov">          0 :           log.printf(&quot; +++ WARNING +++ previous bias factor was inf while now it is %g\n&quot;,biasfactor_);</span></a>
<a name="498"><span class="lineNum">     498 </span>            :       }</a>
<a name="499"><span class="lineNum">     499 </span>            :       else</a>
<a name="500"><span class="lineNum">     500 </span>            :       {</a>
<a name="501"><span class="lineNum">     501 </span>            :         double old_biasfactor;</a>
<a name="502"><span class="lineNum">     502 </span><span class="lineCov">          6 :         ifile.scanField(&quot;biasfactor&quot;,old_biasfactor);</span></a>
<a name="503"><span class="lineNum">     503 </span><span class="lineCov">          6 :         if(std::abs(biasfactor_-old_biasfactor)&gt;1e-6*biasfactor_)</span></a>
<a name="504"><span class="lineNum">     504 </span><span class="lineNoCov">          0 :           log.printf(&quot; +++ WARNING +++ previous bias factor was %g while now it is %g. diff = %g\n&quot;,old_biasfactor,biasfactor_,biasfactor_-old_biasfactor);</span></a>
<a name="505"><span class="lineNum">     505 </span>            :       }</a>
<a name="506"><span class="lineNum">     506 </span>            :       double old_epsilon;</a>
<a name="507"><span class="lineNum">     507 </span><span class="lineCov">          8 :       ifile.scanField(&quot;epsilon&quot;,old_epsilon);</span></a>
<a name="508"><span class="lineNum">     508 </span><span class="lineCov">          8 :       if(std::abs(epsilon_-old_epsilon)&gt;1e-6*epsilon_)</span></a>
<a name="509"><span class="lineNum">     509 </span><span class="lineCov">          6 :         log.printf(&quot; +++ WARNING +++ previous epsilon was %g while now it is %g. diff = %g\n&quot;,old_epsilon,epsilon_,epsilon_-old_epsilon);</span></a>
<a name="510"><span class="lineNum">     510 </span>            :       double old_cutoff;</a>
<a name="511"><span class="lineNum">     511 </span><span class="lineCov">          8 :       ifile.scanField(&quot;kernel_cutoff&quot;,old_cutoff);</span></a>
<a name="512"><span class="lineNum">     512 </span><span class="lineCov">          8 :       if(std::abs(cutoff-old_cutoff)&gt;1e-6*cutoff)</span></a>
<a name="513"><span class="lineNum">     513 </span><span class="lineNoCov">          0 :         log.printf(&quot; +++ WARNING +++ previous kernel_cutoff was %g while now it is %g. diff = %g\n&quot;,old_cutoff,cutoff,cutoff-old_cutoff);</span></a>
<a name="514"><span class="lineNum">     514 </span>            :       double old_threshold;</a>
<a name="515"><span class="lineNum">     515 </span><span class="lineCov">          8 :       const double threshold=sqrt(threshold2_);</span></a>
<a name="516"><span class="lineNum">     516 </span><span class="lineCov">          8 :       ifile.scanField(&quot;compression_threshold&quot;,old_threshold);</span></a>
<a name="517"><span class="lineNum">     517 </span><span class="lineCov">          8 :       if(std::abs(threshold-old_threshold)&gt;1e-6*threshold)</span></a>
<a name="518"><span class="lineNum">     518 </span><span class="lineNoCov">          0 :         log.printf(&quot; +++ WARNING +++ previous compression_threshold was %g while now it is %g. diff = %g\n&quot;,old_threshold,threshold,threshold-old_threshold);</span></a>
<a name="519"><span class="lineNum">     519 </span><span class="lineCov">          8 :       if(stateRestart)</span></a>
<a name="520"><span class="lineNum">     520 </span>            :       {</a>
<a name="521"><span class="lineNum">     521 </span><span class="lineCov">          4 :         ifile.scanField(&quot;zed&quot;,Zed_);</span></a>
<a name="522"><span class="lineNum">     522 </span><span class="lineCov">          4 :         ifile.scanField(&quot;sum_weights&quot;,sum_weights_);</span></a>
<a name="523"><span class="lineNum">     523 </span><span class="lineCov">          4 :         ifile.scanField(&quot;sum_weights2&quot;,sum_weights2_);</span></a>
<a name="524"><span class="lineNum">     524 </span><span class="lineCov">          4 :         ifile.scanField(&quot;counter&quot;,counter_);</span></a>
<a name="525"><span class="lineNum">     525 </span><span class="lineCov">          4 :         if(adaptive_sigma_)</span></a>
<a name="526"><span class="lineNum">     526 </span>            :         {</a>
<a name="527"><span class="lineNum">     527 </span><span class="lineCov">          4 :           ifile.scanField(&quot;adaptive_counter&quot;,adaptive_counter_);</span></a>
<a name="528"><span class="lineNum">     528 </span><span class="lineCov">          4 :           if(NumWalkers_==1)</span></a>
<a name="529"><span class="lineNum">     529 </span>            :           {</a>
<a name="530"><span class="lineNum">     530 </span><span class="lineCov">          6 :             for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="531"><span class="lineNum">     531 </span>            :             {</a>
<a name="532"><span class="lineNum">     532 </span><span class="lineCov">          8 :               ifile.scanField(&quot;sigma0_&quot;+getPntrToArgument(i)-&gt;getName(),sigma0_[i]);</span></a>
<a name="533"><span class="lineNum">     533 </span><span class="lineCov">          8 :               ifile.scanField(&quot;av_cv_&quot;+getPntrToArgument(i)-&gt;getName(),av_cv_[i]);</span></a>
<a name="534"><span class="lineNum">     534 </span><span class="lineCov">          8 :               ifile.scanField(&quot;av_M2_&quot;+getPntrToArgument(i)-&gt;getName(),av_M2_[i]);</span></a>
<a name="535"><span class="lineNum">     535 </span>            :             }</a>
<a name="536"><span class="lineNum">     536 </span>            :           }</a>
<a name="537"><span class="lineNum">     537 </span>            :           else</a>
<a name="538"><span class="lineNum">     538 </span>            :           {</a>
<a name="539"><span class="lineNum">     539 </span><span class="lineCov">          6 :             for(unsigned w=0; w&lt;NumWalkers_; w++)</span></a>
<a name="540"><span class="lineNum">     540 </span><span class="lineCov">         12 :               for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="541"><span class="lineNum">     541 </span>            :               {</a>
<a name="542"><span class="lineNum">     542 </span>            :                 double tmp0,tmp1,tmp2;</a>
<a name="543"><span class="lineNum">     543 </span><span class="lineCov">         16 :                 const std::string arg_iw=getPntrToArgument(i)-&gt;getName()+&quot;_&quot;+std::to_string(w);</span></a>
<a name="544"><span class="lineNum">     544 </span><span class="lineCov">          8 :                 ifile.scanField(&quot;sigma0_&quot;+arg_iw,tmp0);</span></a>
<a name="545"><span class="lineNum">     545 </span><span class="lineCov">          8 :                 ifile.scanField(&quot;av_cv_&quot;+arg_iw,tmp1);</span></a>
<a name="546"><span class="lineNum">     546 </span><span class="lineCov">          8 :                 ifile.scanField(&quot;av_M2_&quot;+arg_iw,tmp2);</span></a>
<a name="547"><span class="lineNum">     547 </span><span class="lineCov">          8 :                 if(w==walker_rank_)</span></a>
<a name="548"><span class="lineNum">     548 </span>            :                 {</a>
<a name="549"><span class="lineNum">     549 </span><span class="lineCov">          4 :                   sigma0_[i]=tmp0;</span></a>
<a name="550"><span class="lineNum">     550 </span><span class="lineCov">          4 :                   av_cv_[i]=tmp1;</span></a>
<a name="551"><span class="lineNum">     551 </span><span class="lineCov">          4 :                   av_M2_[i]=tmp2;</span></a>
<a name="552"><span class="lineNum">     552 </span>            :                 }</a>
<a name="553"><span class="lineNum">     553 </span>            :               }</a>
<a name="554"><span class="lineNum">     554 </span>            :           }</a>
<a name="555"><span class="lineNum">     555 </span>            :         }</a>
<a name="556"><span class="lineNum">     556 </span>            :       }</a>
<a name="557"><span class="lineNum">     557 </span><span class="lineCov">         24 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="558"><span class="lineNum">     558 </span>            :       {</a>
<a name="559"><span class="lineNum">     559 </span><span class="lineCov">         16 :         if(getPntrToArgument(i)-&gt;isPeriodic())</span></a>
<a name="560"><span class="lineNum">     560 </span>            :         {</a>
<a name="561"><span class="lineNum">     561 </span>            :           std::string arg_min,arg_max;</a>
<a name="562"><span class="lineNum">     562 </span><span class="lineCov">         16 :           getPntrToArgument(i)-&gt;getDomain(arg_min,arg_max);</span></a>
<a name="563"><span class="lineNum">     563 </span>            :           std::string file_min,file_max;</a>
<a name="564"><span class="lineNum">     564 </span><span class="lineCov">         32 :           ifile.scanField(&quot;min_&quot;+getPntrToArgument(i)-&gt;getName(),file_min);</span></a>
<a name="565"><span class="lineNum">     565 </span><span class="lineCov">         16 :           ifile.scanField(&quot;max_&quot;+getPntrToArgument(i)-&gt;getName(),file_max);</span></a>
<a name="566"><span class="lineNum">     566 </span><span class="lineCov">         16 :           plumed_massert(file_min==arg_min,&quot;RESTART - mismatch between old and new ARG periodicity&quot;);</span></a>
<a name="567"><span class="lineNum">     567 </span><span class="lineCov">         16 :           plumed_massert(file_max==arg_max,&quot;RESTART - mismatch between old and new ARG periodicity&quot;);</span></a>
<a name="568"><span class="lineNum">     568 </span>            :         }</a>
<a name="569"><span class="lineNum">     569 </span>            :       }</a>
<a name="570"><span class="lineNum">     570 </span><span class="lineCov">          8 :       if(stateRestart)</span></a>
<a name="571"><span class="lineNum">     571 </span>            :       {</a>
<a name="572"><span class="lineNum">     572 </span>            :         double time;</a>
<a name="573"><span class="lineNum">     573 </span><span class="lineCov">         48 :         while(ifile.scanField(&quot;time&quot;,time))</span></a>
<a name="574"><span class="lineNum">     574 </span>            :         {</a>
<a name="575"><span class="lineNum">     575 </span><span class="lineCov">         20 :           std::vector&lt;double&gt; center(ncv_);</span></a>
<a name="576"><span class="lineNum">     576 </span><span class="lineCov">         20 :           std::vector&lt;double&gt; sigma(ncv_);</span></a>
<a name="577"><span class="lineNum">     577 </span>            :           double height;</a>
<a name="578"><span class="lineNum">     578 </span><span class="lineCov">         60 :           for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="579"><span class="lineNum">     579 </span><span class="lineCov">         40 :             ifile.scanField(getPntrToArgument(i)-&gt;getName(),center[i]);</span></a>
<a name="580"><span class="lineNum">     580 </span><span class="lineCov">         60 :           for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="581"><span class="lineNum">     581 </span><span class="lineCov">         80 :             ifile.scanField(&quot;sigma_&quot;+getPntrToArgument(i)-&gt;getName(),sigma[i]);</span></a>
<a name="582"><span class="lineNum">     582 </span><span class="lineCov">         20 :           ifile.scanField(&quot;height&quot;,height);</span></a>
<a name="583"><span class="lineNum">     583 </span><span class="lineCov">         20 :           ifile.scanField();</span></a>
<a name="584"><span class="lineNum">     584 </span><span class="lineCov">         20 :           kernels_.emplace_back(height,center,sigma);</span></a>
<a name="585"><span class="lineNum">     585 </span>            :         }</a>
<a name="586"><span class="lineNum">     586 </span><span class="lineCov">          4 :         log.printf(&quot;    a total of %lu kernels where read\n&quot;,kernels_.size());</span></a>
<a name="587"><span class="lineNum">     587 </span>            :       }</a>
<a name="588"><span class="lineNum">     588 </span>            :       else</a>
<a name="589"><span class="lineNum">     589 </span>            :       {</a>
<a name="590"><span class="lineNum">     590 </span><span class="lineCov">          4 :         ifile.allowIgnoredFields(); //this allows for multiple restart, but without checking for consistency between them!</span></a>
<a name="591"><span class="lineNum">     591 </span>            :         double time;</a>
<a name="592"><span class="lineNum">     592 </span><span class="lineCov">        248 :         while(ifile.scanField(&quot;time&quot;,time))</span></a>
<a name="593"><span class="lineNum">     593 </span>            :         {</a>
<a name="594"><span class="lineNum">     594 </span><span class="lineCov">        120 :           std::vector&lt;double&gt; center(ncv_);</span></a>
<a name="595"><span class="lineNum">     595 </span><span class="lineCov">        120 :           std::vector&lt;double&gt; sigma(ncv_);</span></a>
<a name="596"><span class="lineNum">     596 </span>            :           double height;</a>
<a name="597"><span class="lineNum">     597 </span>            :           double logweight;</a>
<a name="598"><span class="lineNum">     598 </span><span class="lineCov">        360 :           for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="599"><span class="lineNum">     599 </span><span class="lineCov">        240 :             ifile.scanField(getPntrToArgument(i)-&gt;getName(),center[i]);</span></a>
<a name="600"><span class="lineNum">     600 </span><span class="lineCov">        360 :           for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="601"><span class="lineNum">     601 </span><span class="lineCov">        480 :             ifile.scanField(&quot;sigma_&quot;+getPntrToArgument(i)-&gt;getName(),sigma[i]);</span></a>
<a name="602"><span class="lineNum">     602 </span><span class="lineCov">        120 :           if(counter_==(1+walker_rank_) &amp;&amp; adaptive_sigma_)</span></a>
<a name="603"><span class="lineNum">     603 </span><span class="lineNoCov">          0 :             sigma0_=sigma;</span></a>
<a name="604"><span class="lineNum">     604 </span><span class="lineCov">        120 :           ifile.scanField(&quot;height&quot;,height);</span></a>
<a name="605"><span class="lineNum">     605 </span><span class="lineCov">        120 :           ifile.scanField(&quot;logweight&quot;,logweight);</span></a>
<a name="606"><span class="lineNum">     606 </span><span class="lineCov">        120 :           ifile.scanField();</span></a>
<a name="607"><span class="lineNum">     607 </span><span class="lineCov">        120 :           addKernel(height,center,sigma);</span></a>
<a name="608"><span class="lineNum">     608 </span><span class="lineCov">        120 :           const double weight=std::exp(logweight);</span></a>
<a name="609"><span class="lineNum">     609 </span><span class="lineCov">        120 :           sum_weights_+=weight; //this sum is slightly inaccurate, because when printing some precision is lost</span></a>
<a name="610"><span class="lineNum">     610 </span><span class="lineCov">        120 :           sum_weights2_+=weight*weight;</span></a>
<a name="611"><span class="lineNum">     611 </span><span class="lineCov">        120 :           counter_++;</span></a>
<a name="612"><span class="lineNum">     612 </span>            :         }</a>
<a name="613"><span class="lineNum">     613 </span><span class="lineCov">          4 :         KDEnorm_=sum_weights_;</span></a>
<a name="614"><span class="lineNum">     614 </span><span class="lineCov">          4 :         if(!no_Zed_)</span></a>
<a name="615"><span class="lineNum">     615 </span>            :         {</a>
<a name="616"><span class="lineNum">     616 </span><span class="lineCov">          2 :           double sum_uprob=0;</span></a>
<a name="617"><span class="lineNum">     617 </span><span class="lineCov">         48 :           for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</span></a>
<a name="618"><span class="lineNum">     618 </span><span class="lineCov">       1104 :             for(unsigned kk=0; kk&lt;kernels_.size(); kk++)</span></a>
<a name="619"><span class="lineNum">     619 </span><span class="lineCov">       1058 :               sum_uprob+=evaluateKernel(kernels_[kk],kernels_[k].center);</span></a>
<a name="620"><span class="lineNum">     620 </span><span class="lineCov">          2 :           if(NumParallel_&gt;1)</span></a>
<a name="621"><span class="lineNum">     621 </span><span class="lineNoCov">          0 :             comm.Sum(sum_uprob);</span></a>
<a name="622"><span class="lineNum">     622 </span><span class="lineCov">          2 :           Zed_=sum_uprob/KDEnorm_/kernels_.size();</span></a>
<a name="623"><span class="lineNum">     623 </span>            :         }</a>
<a name="624"><span class="lineNum">     624 </span><span class="lineCov">          4 :         log.printf(&quot;    a total of %lu kernels where read, and compressed to %lu\n&quot;,counter_-1,kernels_.size());</span></a>
<a name="625"><span class="lineNum">     625 </span>            :         convertKernelsToState=true;</a>
<a name="626"><span class="lineNum">     626 </span>            :       }</a>
<a name="627"><span class="lineNum">     627 </span><span class="lineCov">          8 :       ifile.reset(false);</span></a>
<a name="628"><span class="lineNum">     628 </span><span class="lineCov">          8 :       ifile.close();</span></a>
<a name="629"><span class="lineNum">     629 </span><span class="lineCov">          8 :       nlist_=tmp_nlist;</span></a>
<a name="630"><span class="lineNum">     630 </span>            :     }</a>
<a name="631"><span class="lineNum">     631 </span>            :     else</a>
<a name="632"><span class="lineNum">     632 </span>            :     { //same behaviour as METAD</a>
<a name="633"><span class="lineNum">     633 </span><span class="lineCov">          2 :       std::string not_found_msg=&quot;RESTART requested, but file '&quot;+restartFileName+&quot;' was not found!&quot;;</span></a>
<a name="634"><span class="lineNum">     634 </span><span class="lineCov">          2 :       if(stateRestart)</span></a>
<a name="635"><span class="lineNum">     635 </span><span class="lineNoCov">          0 :         plumed_merror(not_found_msg);</span></a>
<a name="636"><span class="lineNum">     636 </span>            :       else</a>
<a name="637"><span class="lineNum">     637 </span><span class="lineCov">          2 :         log.printf(&quot; +++ WARNING +++ %s\n&quot;,not_found_msg.c_str());</span></a>
<a name="638"><span class="lineNum">     638 </span>            :     }</a>
<a name="639"><span class="lineNum">     639 </span><span class="lineCov">         10 :     if(NumWalkers_&gt;1) //make sure that all walkers are doing the same thing</span></a>
<a name="640"><span class="lineNum">     640 </span>            :     {</a>
<a name="641"><span class="lineNum">     641 </span><span class="lineCov">          4 :       const unsigned kernels_size=kernels_.size();</span></a>
<a name="642"><span class="lineNum">     642 </span><span class="lineCov">          4 :       std::vector&lt;unsigned&gt; all_kernels_size(NumWalkers_);</span></a>
<a name="643"><span class="lineNum">     643 </span><span class="lineCov">          4 :       if(comm.Get_rank()==0)</span></a>
<a name="644"><span class="lineNum">     644 </span><span class="lineCov">          4 :         multi_sim_comm.Allgather(kernels_size,all_kernels_size);</span></a>
<a name="645"><span class="lineNum">     645 </span><span class="lineCov">          4 :       comm.Bcast(all_kernels_size,0);</span></a>
<a name="646"><span class="lineNum">     646 </span>            :       bool same_number_of_kernels=true;</a>
<a name="647"><span class="lineNum">     647 </span><span class="lineCov">          8 :       for(unsigned w=1; w&lt;NumWalkers_; w++)</span></a>
<a name="648"><span class="lineNum">     648 </span><span class="lineCov">          4 :         if(all_kernels_size[0]!=all_kernels_size[w])</span></a>
<a name="649"><span class="lineNum">     649 </span>            :           same_number_of_kernels=false;</a>
<a name="650"><span class="lineNum">     650 </span><span class="lineCov">          4 :       plumed_massert(same_number_of_kernels,&quot;RESTART - not all walkers are reading the same file!&quot;);</span></a>
<a name="651"><span class="lineNum">     651 </span>            :     }</a>
<a name="652"><span class="lineNum">     652 </span>            :   }</a>
<a name="653"><span class="lineNum">     653 </span><span class="lineCov">          2 :   else if(restartFileName.length()&gt;0)</span></a>
<a name="654"><span class="lineNum">     654 </span><span class="lineCov">          2 :     log.printf(&quot; +++ WARNING +++ the provided STATE_RFILE will be ignored, since RESTART was not requested\n&quot;);</span></a>
<a name="655"><span class="lineNum">     655 </span>            : </a>
<a name="656"><span class="lineNum">     656 </span>            : //sync all walkers to avoid opening files before reading is over (see also METAD)</a>
<a name="657"><span class="lineNum">     657 </span><span class="lineCov">         12 :   comm.Barrier();</span></a>
<a name="658"><span class="lineNum">     658 </span><span class="lineCov">         12 :   if(comm.Get_rank()==0 &amp;&amp; walkers_mpi)</span></a>
<a name="659"><span class="lineNum">     659 </span><span class="lineCov">          6 :     multi_sim_comm.Barrier();</span></a>
<a name="660"><span class="lineNum">     660 </span>            : </a>
<a name="661"><span class="lineNum">     661 </span>            : //setup output kernels file</a>
<a name="662"><span class="lineNum">     662 </span><span class="lineCov">         12 :   kernelsOfile_.link(*this);</span></a>
<a name="663"><span class="lineNum">     663 </span><span class="lineCov">         12 :   if(NumWalkers_&gt;1)</span></a>
<a name="664"><span class="lineNum">     664 </span>            :   {</a>
<a name="665"><span class="lineNum">     665 </span><span class="lineCov">          6 :     if(walker_rank_&gt;0)</span></a>
<a name="666"><span class="lineNum">     666 </span>            :       kernelsFileName=&quot;/dev/null&quot;; //only first walker writes on file</a>
<a name="667"><span class="lineNum">     667 </span><span class="lineCov">         12 :     kernelsOfile_.enforceSuffix(&quot;&quot;);</span></a>
<a name="668"><span class="lineNum">     668 </span>            :   }</a>
<a name="669"><span class="lineNum">     669 </span><span class="lineCov">         12 :   kernelsOfile_.open(kernelsFileName);</span></a>
<a name="670"><span class="lineNum">     670 </span><span class="lineCov">         12 :   if(fmt.length()&gt;0)</span></a>
<a name="671"><span class="lineNum">     671 </span><span class="lineCov">         24 :     kernelsOfile_.fmtField(&quot; &quot;+fmt);</span></a>
<a name="672"><span class="lineNum">     672 </span>            :   kernelsOfile_.setHeavyFlush(); //do I need it?</a>
<a name="673"><span class="lineNum">     673 </span>            :   //define and set const fields</a>
<a name="674"><span class="lineNum">     674 </span><span class="lineCov">         12 :   kernelsOfile_.addConstantField(&quot;action&quot;);</span></a>
<a name="675"><span class="lineNum">     675 </span><span class="lineCov">         12 :   kernelsOfile_.addConstantField(&quot;biasfactor&quot;);</span></a>
<a name="676"><span class="lineNum">     676 </span><span class="lineCov">         12 :   kernelsOfile_.addConstantField(&quot;epsilon&quot;);</span></a>
<a name="677"><span class="lineNum">     677 </span><span class="lineCov">         12 :   kernelsOfile_.addConstantField(&quot;kernel_cutoff&quot;);</span></a>
<a name="678"><span class="lineNum">     678 </span><span class="lineCov">         24 :   kernelsOfile_.addConstantField(&quot;compression_threshold&quot;);</span></a>
<a name="679"><span class="lineNum">     679 </span><span class="lineCov">         36 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="680"><span class="lineNum">     680 </span><span class="lineCov">         24 :     kernelsOfile_.setupPrintValue(getPntrToArgument(i));</span></a>
<a name="681"><span class="lineNum">     681 </span><span class="lineCov">         24 :   kernelsOfile_.printField(&quot;action&quot;,getName()+&quot;_kernels&quot;);</span></a>
<a name="682"><span class="lineNum">     682 </span><span class="lineCov">         12 :   kernelsOfile_.printField(&quot;biasfactor&quot;,biasfactor_);</span></a>
<a name="683"><span class="lineNum">     683 </span><span class="lineCov">         12 :   kernelsOfile_.printField(&quot;epsilon&quot;,epsilon_);</span></a>
<a name="684"><span class="lineNum">     684 </span><span class="lineCov">         12 :   kernelsOfile_.printField(&quot;kernel_cutoff&quot;,sqrt(cutoff2_));</span></a>
<a name="685"><span class="lineNum">     685 </span><span class="lineCov">         12 :   kernelsOfile_.printField(&quot;compression_threshold&quot;,sqrt(threshold2_));</span></a>
<a name="686"><span class="lineNum">     686 </span>            : </a>
<a name="687"><span class="lineNum">     687 </span>            : //open file for storing state</a>
<a name="688"><span class="lineNum">     688 </span><span class="lineCov">         12 :   if(wStateStride_!=0)</span></a>
<a name="689"><span class="lineNum">     689 </span>            :   {</a>
<a name="690"><span class="lineNum">     690 </span><span class="lineCov">          6 :     stateOfile_.link(*this);</span></a>
<a name="691"><span class="lineNum">     691 </span><span class="lineCov">          6 :     if(NumWalkers_&gt;1)</span></a>
<a name="692"><span class="lineNum">     692 </span>            :     {</a>
<a name="693"><span class="lineNum">     693 </span><span class="lineCov">          4 :       if(walker_rank_&gt;0)</span></a>
<a name="694"><span class="lineNum">     694 </span>            :         stateFileName=&quot;/dev/null&quot;; //only first walker writes on file</a>
<a name="695"><span class="lineNum">     695 </span><span class="lineCov">          8 :       stateOfile_.enforceSuffix(&quot;&quot;);</span></a>
<a name="696"><span class="lineNum">     696 </span>            :     }</a>
<a name="697"><span class="lineNum">     697 </span><span class="lineCov">          6 :     stateOfile_.open(stateFileName);</span></a>
<a name="698"><span class="lineNum">     698 </span><span class="lineCov">          6 :     if(fmt.length()&gt;0)</span></a>
<a name="699"><span class="lineNum">     699 </span><span class="lineCov">         12 :       stateOfile_.fmtField(&quot; &quot;+fmt);</span></a>
<a name="700"><span class="lineNum">     700 </span><span class="lineCov">          6 :     if(convertKernelsToState)</span></a>
<a name="701"><span class="lineNum">     701 </span><span class="lineNoCov">          0 :       dumpStateToFile();</span></a>
<a name="702"><span class="lineNum">     702 </span>            :   }</a>
<a name="703"><span class="lineNum">     703 </span>            : </a>
<a name="704"><span class="lineNum">     704 </span>            : //set initial old values</a>
<a name="705"><span class="lineNum">     705 </span><span class="lineCov">         12 :   KDEnorm_=sum_weights_;</span></a>
<a name="706"><span class="lineNum">     706 </span><span class="lineCov">         12 :   old_KDEnorm_=KDEnorm_;</span></a>
<a name="707"><span class="lineNum">     707 </span>            : </a>
<a name="708"><span class="lineNum">     708 </span>            : //add and set output components</a>
<a name="709"><span class="lineNum">     709 </span><span class="lineCov">         12 :   addComponent(&quot;rct&quot;);</span></a>
<a name="710"><span class="lineNum">     710 </span><span class="lineCov">         12 :   componentIsNotPeriodic(&quot;rct&quot;);</span></a>
<a name="711"><span class="lineNum">     711 </span><span class="lineCov">         12 :   getPntrToComponent(&quot;rct&quot;)-&gt;set(kbt_*std::log(sum_weights_/counter_));</span></a>
<a name="712"><span class="lineNum">     712 </span><span class="lineCov">         12 :   addComponent(&quot;zed&quot;);</span></a>
<a name="713"><span class="lineNum">     713 </span><span class="lineCov">         12 :   componentIsNotPeriodic(&quot;zed&quot;);</span></a>
<a name="714"><span class="lineNum">     714 </span><span class="lineCov">         12 :   getPntrToComponent(&quot;zed&quot;)-&gt;set(Zed_);</span></a>
<a name="715"><span class="lineNum">     715 </span><span class="lineCov">         12 :   addComponent(&quot;neff&quot;);</span></a>
<a name="716"><span class="lineNum">     716 </span><span class="lineCov">         12 :   componentIsNotPeriodic(&quot;neff&quot;);</span></a>
<a name="717"><span class="lineNum">     717 </span><span class="lineCov">         12 :   getPntrToComponent(&quot;neff&quot;)-&gt;set(std::pow(1+sum_weights_,2)/(1+sum_weights2_));</span></a>
<a name="718"><span class="lineNum">     718 </span><span class="lineCov">         12 :   addComponent(&quot;nker&quot;);</span></a>
<a name="719"><span class="lineNum">     719 </span><span class="lineCov">         12 :   componentIsNotPeriodic(&quot;nker&quot;);</span></a>
<a name="720"><span class="lineNum">     720 </span><span class="lineCov">         12 :   getPntrToComponent(&quot;nker&quot;)-&gt;set(kernels_.size());</span></a>
<a name="721"><span class="lineNum">     721 </span><span class="lineCov">         12 :   if(calc_work_)</span></a>
<a name="722"><span class="lineNum">     722 </span>            :   {</a>
<a name="723"><span class="lineNum">     723 </span><span class="lineCov">          4 :     addComponent(&quot;work&quot;);</span></a>
<a name="724"><span class="lineNum">     724 </span><span class="lineCov">          8 :     componentIsNotPeriodic(&quot;work&quot;);</span></a>
<a name="725"><span class="lineNum">     725 </span>            :   }</a>
<a name="726"><span class="lineNum">     726 </span><span class="lineCov">         12 :   if(nlist_)</span></a>
<a name="727"><span class="lineNum">     727 </span>            :   {</a>
<a name="728"><span class="lineNum">     728 </span><span class="lineCov">          4 :     addComponent(&quot;nlker&quot;);</span></a>
<a name="729"><span class="lineNum">     729 </span><span class="lineCov">          4 :     componentIsNotPeriodic(&quot;nlker&quot;);</span></a>
<a name="730"><span class="lineNum">     730 </span><span class="lineCov">          4 :     addComponent(&quot;nlsteps&quot;);</span></a>
<a name="731"><span class="lineNum">     731 </span><span class="lineCov">          8 :     componentIsNotPeriodic(&quot;nlsteps&quot;);</span></a>
<a name="732"><span class="lineNum">     732 </span>            :   }</a>
<a name="733"><span class="lineNum">     733 </span>            : </a>
<a name="734"><span class="lineNum">     734 </span>            : //printing some info</a>
<a name="735"><span class="lineNum">     735 </span><span class="lineCov">         12 :   log.printf(&quot;  temperature = %g\n&quot;,kbt_/Kb);</span></a>
<a name="736"><span class="lineNum">     736 </span><span class="lineCov">         12 :   log.printf(&quot;  beta = %g\n&quot;,1./kbt_);</span></a>
<a name="737"><span class="lineNum">     737 </span><span class="lineCov">         12 :   log.printf(&quot;  depositing new kernels with PACE = %u\n&quot;,stride_);</span></a>
<a name="738"><span class="lineNum">     738 </span><span class="lineCov">         12 :   log.printf(&quot;  expected BARRIER is %g\n&quot;,barrier);</span></a>
<a name="739"><span class="lineNum">     739 </span><span class="lineCov">         12 :   log.printf(&quot;  using target distribution with BIASFACTOR gamma = %g\n&quot;,biasfactor_);</span></a>
<a name="740"><span class="lineNum">     740 </span><span class="lineCov">         12 :   if(std::isinf(biasfactor_))</span></a>
<a name="741"><span class="lineNum">     741 </span><span class="lineCov">          4 :     log.printf(&quot;    (thus a uniform flat target distribution, no well-tempering)\n&quot;);</span></a>
<a name="742"><span class="lineNum">     742 </span><span class="lineCov">         12 :   if(adaptive_sigma_)</span></a>
<a name="743"><span class="lineNum">     743 </span>            :   {</a>
<a name="744"><span class="lineNum">     744 </span><span class="lineCov">          6 :     log.printf(&quot;  adaptive SIGMA will be used, with ADAPTIVE_SIGMA_STRIDE = %u\n&quot;,adaptive_sigma_stride_);</span></a>
<a name="745"><span class="lineNum">     745 </span><span class="lineCov">          6 :     unsigned x=std::ceil(adaptive_sigma_stride_/stride_);</span></a>
<a name="746"><span class="lineNum">     746 </span><span class="lineCov">          6 :     log.printf(&quot;    thus the first x kernel depositions will be skipped, x = ADAPTIVE_SIGMA_STRIDE/PACE = %u\n&quot;,x);</span></a>
<a name="747"><span class="lineNum">     747 </span>            :   }</a>
<a name="748"><span class="lineNum">     748 </span>            :   else</a>
<a name="749"><span class="lineNum">     749 </span>            :   {</a>
<a name="750"><span class="lineNum">     750 </span><span class="lineCov">          6 :     log.printf(&quot;  kernels have initial SIGMA = &quot;);</span></a>
<a name="751"><span class="lineNum">     751 </span><span class="lineCov">         18 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="752"><span class="lineNum">     752 </span><span class="lineCov">         12 :       log.printf(&quot; %g&quot;,sigma0_[i]);</span></a>
<a name="753"><span class="lineNum">     753 </span><span class="lineCov">          6 :     log.printf(&quot;\n&quot;);</span></a>
<a name="754"><span class="lineNum">     754 </span>            :   }</a>
<a name="755"><span class="lineNum">     755 </span><span class="lineCov">         12 :   if(sigma_min_.size()&gt;0)</span></a>
<a name="756"><span class="lineNum">     756 </span>            :   {</a>
<a name="757"><span class="lineNum">     757 </span><span class="lineCov">          2 :     log.printf(&quot;  kernels have a SIGMA_MIN = &quot;);</span></a>
<a name="758"><span class="lineNum">     758 </span><span class="lineCov">          6 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="759"><span class="lineNum">     759 </span><span class="lineCov">          4 :       log.printf(&quot; %g&quot;,sigma_min_[i]);</span></a>
<a name="760"><span class="lineNum">     760 </span><span class="lineCov">          2 :     log.printf(&quot;\n&quot;);</span></a>
<a name="761"><span class="lineNum">     761 </span>            :   }</a>
<a name="762"><span class="lineNum">     762 </span><span class="lineCov">         12 :   if(fixed_sigma_)</span></a>
<a name="763"><span class="lineNum">     763 </span><span class="lineCov">          4 :     log.printf(&quot; -- FIXED_SIGMA: sigma will not decrease as the simulation proceeds\n&quot;);</span></a>
<a name="764"><span class="lineNum">     764 </span><span class="lineCov">         12 :   log.printf(&quot;  kernels are truncated with KERNELS_CUTOFF = %g\n&quot;,cutoff);</span></a>
<a name="765"><span class="lineNum">     765 </span><span class="lineCov">         12 :   if(cutoff&lt;3.5)</span></a>
<a name="766"><span class="lineNum">     766 </span><span class="lineNoCov">          0 :     log.printf(&quot; +++ WARNING +++ probably kernels are truncated too much\n&quot;);</span></a>
<a name="767"><span class="lineNum">     767 </span><span class="lineCov">         12 :   log.printf(&quot;  the value at cutoff is = %g\n&quot;,val_at_cutoff_);</span></a>
<a name="768"><span class="lineNum">     768 </span><span class="lineCov">         12 :   log.printf(&quot;  regularization EPSILON = %g\n&quot;,epsilon_);</span></a>
<a name="769"><span class="lineNum">     769 </span><span class="lineCov">         12 :   if(val_at_cutoff_&gt;epsilon_*(1+1e-6))</span></a>
<a name="770"><span class="lineNum">     770 </span><span class="lineNoCov">          0 :     log.printf(&quot; +++ WARNING +++ the KERNEL_CUTOFF might be too small for the given EPSILON\n&quot;);</span></a>
<a name="771"><span class="lineNum">     771 </span><span class="lineCov">         12 :   log.printf(&quot;  kernels will be compressed when closer than COMPRESSION_THRESHOLD = %g\n&quot;,sqrt(threshold2_));</span></a>
<a name="772"><span class="lineNum">     772 </span><span class="lineCov">         12 :   if(threshold2_==0)</span></a>
<a name="773"><span class="lineNum">     773 </span><span class="lineNoCov">          0 :     log.printf(&quot; +++ WARNING +++ kernels will never merge, expect slowdowns\n&quot;);</span></a>
<a name="774"><span class="lineNum">     774 </span><span class="lineCov">         12 :   if(!recursive_merge_)</span></a>
<a name="775"><span class="lineNum">     775 </span><span class="lineCov">          4 :     log.printf(&quot; -- RECURSIVE_MERGE_OFF: only one merge for each new kernel will be attempted. This is faster only if total number of kernels does not grow too much\n&quot;);</span></a>
<a name="776"><span class="lineNum">     776 </span><span class="lineCov">         12 :   if(nlist_)</span></a>
<a name="777"><span class="lineNum">     777 </span><span class="lineCov">          4 :     log.printf(&quot; -- NLIST: using neighbor list for kernels, with parameters: %g,%g\n&quot;,nlist_param_[0],nlist_param_[1]);</span></a>
<a name="778"><span class="lineNum">     778 </span><span class="lineCov">         12 :   if(nlist_pace_reset_)</span></a>
<a name="779"><span class="lineNum">     779 </span><span class="lineCov">          2 :     log.printf(&quot; -- NLIST_PACE_RESET: forcing the neighbor list to update every PACE\n&quot;);</span></a>
<a name="780"><span class="lineNum">     780 </span><span class="lineCov">         12 :   if(no_Zed_)</span></a>
<a name="781"><span class="lineNum">     781 </span><span class="lineCov">          4 :     log.printf(&quot; -- NO_ZED: using fixed normalization factor = %g\n&quot;,Zed_);</span></a>
<a name="782"><span class="lineNum">     782 </span><span class="lineCov">         12 :   if(wStateStride_&gt;0)</span></a>
<a name="783"><span class="lineNum">     783 </span><span class="lineCov">          6 :     log.printf(&quot;  state checkpoints are written on file %s every %d MD steps\n&quot;,stateFileName.c_str(),wStateStride_);</span></a>
<a name="784"><span class="lineNum">     784 </span><span class="lineCov">         12 :   if(wStateStride_==-1)</span></a>
<a name="785"><span class="lineNum">     785 </span><span class="lineNoCov">          0 :     log.printf(&quot;  state checkpoints are written on file %s only on CPT events (or never if MD code does define them!)\n&quot;,stateFileName.c_str());</span></a>
<a name="786"><span class="lineNum">     786 </span><span class="lineCov">         12 :   if(walkers_mpi)</span></a>
<a name="787"><span class="lineNum">     787 </span><span class="lineCov">          6 :     log.printf(&quot; -- WALKERS_MPI: if multiple replicas are present, they will share the same bias via MPI\n&quot;);</span></a>
<a name="788"><span class="lineNum">     788 </span><span class="lineCov">         12 :   if(NumWalkers_&gt;1)</span></a>
<a name="789"><span class="lineNum">     789 </span>            :   {</a>
<a name="790"><span class="lineNum">     790 </span><span class="lineCov">          6 :     log.printf(&quot;  using multiple walkers\n&quot;);</span></a>
<a name="791"><span class="lineNum">     791 </span><span class="lineCov">          6 :     log.printf(&quot;    number of walkers: %u\n&quot;,NumWalkers_);</span></a>
<a name="792"><span class="lineNum">     792 </span><span class="lineCov">          6 :     log.printf(&quot;    walker rank: %u\n&quot;,walker_rank_);</span></a>
<a name="793"><span class="lineNum">     793 </span>            :   }</a>
<a name="794"><span class="lineNum">     794 </span><span class="lineCov">         12 :   int mw_warning=0;</span></a>
<a name="795"><span class="lineNum">     795 </span><span class="lineCov">         12 :   if(!walkers_mpi &amp;&amp; comm.Get_rank()==0 &amp;&amp; multi_sim_comm.Get_size()&gt;(int)NumWalkers_)</span></a>
<a name="796"><span class="lineNum">     796 </span><span class="lineNoCov">          0 :     mw_warning=1;</span></a>
<a name="797"><span class="lineNum">     797 </span><span class="lineCov">         12 :   comm.Bcast(mw_warning,0);</span></a>
<a name="798"><span class="lineNum">     798 </span><span class="lineCov">         12 :   if(mw_warning) //log.printf messes up with comm, so never use it without Bcast!</span></a>
<a name="799"><span class="lineNum">     799 </span><span class="lineNoCov">          0 :     log.printf(&quot; +++ WARNING +++ multiple replicas will NOT communicate unless the flag WALKERS_MPI is used\n&quot;);</span></a>
<a name="800"><span class="lineNum">     800 </span><span class="lineCov">         12 :   if(NumParallel_&gt;1)</span></a>
<a name="801"><span class="lineNum">     801 </span><span class="lineCov">          2 :     log.printf(&quot;  using multiple MPI processes per simulation: %u\n&quot;,NumParallel_);</span></a>
<a name="802"><span class="lineNum">     802 </span><span class="lineCov">         12 :   if(NumOMP_&gt;1)</span></a>
<a name="803"><span class="lineNum">     803 </span><span class="lineCov">          8 :     log.printf(&quot;  using multiple OpenMP threads per simulation: %u\n&quot;,NumOMP_);</span></a>
<a name="804"><span class="lineNum">     804 </span><span class="lineCov">         12 :   if(serial)</span></a>
<a name="805"><span class="lineNum">     805 </span><span class="lineCov">          4 :     log.printf(&quot; -- SERIAL: no loop parallelization, despite %d MPI processes and %u OpenMP threads available\n&quot;,comm.Get_size(),OpenMP::getNumThreads());</span></a>
<a name="806"><span class="lineNum">     806 </span><span class="lineCov">         12 :   log.printf(&quot;  Bibliography: &quot;);</span></a>
<a name="807"><span class="lineNum">     807 </span><span class="lineCov">         24 :   log&lt;&lt;plumed.cite(&quot;M. Invernizzi and M. Parrinello, J. Phys. Chem. Lett. 11, 2731-2736 (2020)&quot;);</span></a>
<a name="808"><span class="lineNum">     808 </span><span class="lineCov">         12 :   log.printf(&quot;\n&quot;);</span></a>
<a name="809"><span class="lineNum">     809 </span><span class="lineCov">         12 : }</span></a>
<a name="810"><span class="lineNum">     810 </span>            : </a>
<a name="811"><span class="lineNum">     811 </span><span class="lineCov">        612 : void OPESmetad::calculate()</span></a>
<a name="812"><span class="lineNum">     812 </span>            : {</a>
<a name="813"><span class="lineNum">     813 </span>            : //get cv</a>
<a name="814"><span class="lineNum">     814 </span><span class="lineCov">        612 :   std::vector&lt;double&gt; cv(ncv_);</span></a>
<a name="815"><span class="lineNum">     815 </span><span class="lineCov">       1836 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="816"><span class="lineNum">     816 </span><span class="lineCov">       1224 :     cv[i]=getArgument(i);</span></a>
<a name="817"><span class="lineNum">     817 </span>            : </a>
<a name="818"><span class="lineNum">     818 </span>            : //check neighbor list</a>
<a name="819"><span class="lineNum">     819 </span><span class="lineCov">        612 :   if(nlist_)</span></a>
<a name="820"><span class="lineNum">     820 </span>            :   {</a>
<a name="821"><span class="lineNum">     821 </span><span class="lineCov">        204 :     nlist_steps_++;</span></a>
<a name="822"><span class="lineNum">     822 </span><span class="lineCov">        204 :     if(getExchangeStep())</span></a>
<a name="823"><span class="lineNum">     823 </span><span class="lineNoCov">          0 :       nlist_update_=true;</span></a>
<a name="824"><span class="lineNum">     824 </span>            :     else</a>
<a name="825"><span class="lineNum">     825 </span>            :     {</a>
<a name="826"><span class="lineNum">     826 </span><span class="lineCov">        210 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="827"><span class="lineNum">     827 </span>            :       {</a>
<a name="828"><span class="lineNum">     828 </span><span class="lineCov">        208 :         const double diff_i=difference(i,cv[i],nlist_center_[i]);</span></a>
<a name="829"><span class="lineNum">     829 </span><span class="lineCov">        208 :         if(diff_i*diff_i&gt;nlist_param_[1]*nlist_dev2_[i])</span></a>
<a name="830"><span class="lineNum">     830 </span>            :         {</a>
<a name="831"><span class="lineNum">     831 </span><span class="lineCov">        202 :           nlist_update_=true;</span></a>
<a name="832"><span class="lineNum">     832 </span><span class="lineCov">        202 :           break;</span></a>
<a name="833"><span class="lineNum">     833 </span>            :         }</a>
<a name="834"><span class="lineNum">     834 </span>            :       }</a>
<a name="835"><span class="lineNum">     835 </span>            :     }</a>
<a name="836"><span class="lineNum">     836 </span><span class="lineCov">        204 :     if(nlist_update_)</span></a>
<a name="837"><span class="lineNum">     837 </span><span class="lineCov">        202 :       updateNlist(cv);</span></a>
<a name="838"><span class="lineNum">     838 </span>            :   }</a>
<a name="839"><span class="lineNum">     839 </span>            : </a>
<a name="840"><span class="lineNum">     840 </span>            : //set bias and forces</a>
<a name="841"><span class="lineNum">     841 </span><span class="lineCov">        612 :   std::vector&lt;double&gt; der_prob(ncv_,0);</span></a>
<a name="842"><span class="lineNum">     842 </span><span class="lineCov">        612 :   const double prob=getProbAndDerivatives(cv,der_prob);</span></a>
<a name="843"><span class="lineNum">     843 </span><span class="lineCov">        612 :   current_bias_=kbt_*bias_prefactor_*std::log(prob/Zed_+epsilon_);</span></a>
<a name="844"><span class="lineNum">     844 </span>            :   setBias(current_bias_);</a>
<a name="845"><span class="lineNum">     845 </span><span class="lineCov">       1836 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="846"><span class="lineNum">     846 </span><span class="lineCov">       1224 :     setOutputForce(i,-kbt_*bias_prefactor_/(prob/Zed_+epsilon_)*der_prob[i]/Zed_);</span></a>
<a name="847"><span class="lineNum">     847 </span>            : </a>
<a name="848"><span class="lineNum">     848 </span><span class="lineCov">        612 :   afterCalculate_=true;</span></a>
<a name="849"><span class="lineNum">     849 </span><span class="lineCov">        612 : }</span></a>
<a name="850"><span class="lineNum">     850 </span>            : </a>
<a name="851"><span class="lineNum">     851 </span><span class="lineCov">        612 : void OPESmetad::update()</span></a>
<a name="852"><span class="lineNum">     852 </span>            : {</a>
<a name="853"><span class="lineNum">     853 </span><span class="lineCov">        612 :   if(isFirstStep_)//same in MetaD, useful for restarts?</span></a>
<a name="854"><span class="lineNum">     854 </span>            :   {</a>
<a name="855"><span class="lineNum">     855 </span><span class="lineCov">         12 :     isFirstStep_=false;</span></a>
<a name="856"><span class="lineNum">     856 </span><span class="lineCov">         12 :     return;</span></a>
<a name="857"><span class="lineNum">     857 </span>            :   }</a>
<a name="858"><span class="lineNum">     858 </span>            : </a>
<a name="859"><span class="lineNum">     859 </span>            : //update variance if adaptive sigma</a>
<a name="860"><span class="lineNum">     860 </span><span class="lineCov">        600 :   if(adaptive_sigma_)</span></a>
<a name="861"><span class="lineNum">     861 </span>            :   {</a>
<a name="862"><span class="lineNum">     862 </span><span class="lineCov">        300 :     adaptive_counter_++;</span></a>
<a name="863"><span class="lineNum">     863 </span><span class="lineCov">        300 :     unsigned tau=adaptive_sigma_stride_;</span></a>
<a name="864"><span class="lineNum">     864 </span><span class="lineCov">        300 :     if(adaptive_counter_&lt;adaptive_sigma_stride_)</span></a>
<a name="865"><span class="lineNum">     865 </span><span class="lineCov">         18 :       tau=adaptive_counter_;</span></a>
<a name="866"><span class="lineNum">     866 </span><span class="lineCov">        900 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="867"><span class="lineNum">     867 </span>            :     { //Welford's online algorithm for standard deviation</a>
<a name="868"><span class="lineNum">     868 </span>            :       const double cv_i=getArgument(i);</a>
<a name="869"><span class="lineNum">     869 </span><span class="lineCov">        600 :       const double diff_i=difference(i,av_cv_[i],cv_i);</span></a>
<a name="870"><span class="lineNum">     870 </span><span class="lineCov">        600 :       av_cv_[i]+=diff_i/tau; //exponentially decaying average</span></a>
<a name="871"><span class="lineNum">     871 </span><span class="lineCov">        600 :       av_M2_[i]+=diff_i*difference(i,av_cv_[i],cv_i);</span></a>
<a name="872"><span class="lineNum">     872 </span>            :     }</a>
<a name="873"><span class="lineNum">     873 </span><span class="lineCov">        300 :     if(adaptive_counter_&lt;adaptive_sigma_stride_ &amp;&amp; counter_==1) //counter_&gt;1 if restarting</span></a>
<a name="874"><span class="lineNum">     874 </span>            :       return; //do not apply bias before having measured sigma</a>
<a name="875"><span class="lineNum">     875 </span>            :   }</a>
<a name="876"><span class="lineNum">     876 </span>            : </a>
<a name="877"><span class="lineNum">     877 </span>            : //do update</a>
<a name="878"><span class="lineNum">     878 </span><span class="lineCov">        582 :   if(getStep()%stride_==0)</span></a>
<a name="879"><span class="lineNum">     879 </span>            :   {</a>
<a name="880"><span class="lineNum">     880 </span><span class="lineCov">        178 :     plumed_massert(afterCalculate_,&quot;OPESmetad::update() must be called after OPESmetad::calculate() to work properly&quot;);</span></a>
<a name="881"><span class="lineNum">     881 </span><span class="lineCov">        178 :     afterCalculate_=false; //if needed implementation can be changed to avoid this</span></a>
<a name="882"><span class="lineNum">     882 </span>            : </a>
<a name="883"><span class="lineNum">     883 </span><span class="lineCov">        178 :     old_KDEnorm_=KDEnorm_;</span></a>
<a name="884"><span class="lineNum">     884 </span>            :     delta_kernels_.clear();</a>
<a name="885"><span class="lineNum">     885 </span><span class="lineCov">        178 :     unsigned old_nker=kernels_.size();</span></a>
<a name="886"><span class="lineNum">     886 </span>            : </a>
<a name="887"><span class="lineNum">     887 </span>            :     //get new kernel height</a>
<a name="888"><span class="lineNum">     888 </span><span class="lineCov">        178 :     double height=std::exp(current_bias_/kbt_); //this assumes that calculate() always runs before update()</span></a>
<a name="889"><span class="lineNum">     889 </span>            : </a>
<a name="890"><span class="lineNum">     890 </span>            :     //update sum_weights_ and neff</a>
<a name="891"><span class="lineNum">     891 </span><span class="lineCov">        178 :     double sum_heights=height;</span></a>
<a name="892"><span class="lineNum">     892 </span><span class="lineCov">        178 :     double sum_heights2=height*height;</span></a>
<a name="893"><span class="lineNum">     893 </span><span class="lineCov">        178 :     if(NumWalkers_&gt;1)</span></a>
<a name="894"><span class="lineNum">     894 </span>            :     {</a>
<a name="895"><span class="lineNum">     895 </span><span class="lineCov">         88 :       if(comm.Get_rank()==0)</span></a>
<a name="896"><span class="lineNum">     896 </span>            :       {</a>
<a name="897"><span class="lineNum">     897 </span><span class="lineCov">         88 :         multi_sim_comm.Sum(sum_heights);</span></a>
<a name="898"><span class="lineNum">     898 </span><span class="lineCov">         88 :         multi_sim_comm.Sum(sum_heights2);</span></a>
<a name="899"><span class="lineNum">     899 </span>            :       }</a>
<a name="900"><span class="lineNum">     900 </span><span class="lineCov">         88 :       comm.Bcast(sum_heights,0);</span></a>
<a name="901"><span class="lineNum">     901 </span><span class="lineCov">         88 :       comm.Bcast(sum_heights2,0);</span></a>
<a name="902"><span class="lineNum">     902 </span>            :     }</a>
<a name="903"><span class="lineNum">     903 </span><span class="lineCov">        178 :     counter_+=NumWalkers_;</span></a>
<a name="904"><span class="lineNum">     904 </span><span class="lineCov">        178 :     sum_weights_+=sum_heights;</span></a>
<a name="905"><span class="lineNum">     905 </span><span class="lineCov">        178 :     sum_weights2_+=sum_heights2;</span></a>
<a name="906"><span class="lineNum">     906 </span><span class="lineCov">        178 :     const double neff=std::pow(1+sum_weights_,2)/(1+sum_weights2_); //adding 1 makes it more robust at the start</span></a>
<a name="907"><span class="lineNum">     907 </span><span class="lineCov">        178 :     getPntrToComponent(&quot;rct&quot;)-&gt;set(kbt_*std::log(sum_weights_/counter_));</span></a>
<a name="908"><span class="lineNum">     908 </span><span class="lineCov">        178 :     getPntrToComponent(&quot;neff&quot;)-&gt;set(neff);</span></a>
<a name="909"><span class="lineNum">     909 </span><span class="lineCov">        178 :     KDEnorm_=sum_weights_;</span></a>
<a name="910"><span class="lineNum">     910 </span>            : </a>
<a name="911"><span class="lineNum">     911 </span>            :     //if needed, rescale sigma and height</a>
<a name="912"><span class="lineNum">     912 </span><span class="lineCov">        178 :     std::vector&lt;double&gt; sigma=sigma0_;</span></a>
<a name="913"><span class="lineNum">     913 </span><span class="lineCov">        178 :     if(adaptive_sigma_)</span></a>
<a name="914"><span class="lineNum">     914 </span>            :     {</a>
<a name="915"><span class="lineNum">     915 </span><span class="lineCov">         88 :       const double factor=biasfactor_;</span></a>
<a name="916"><span class="lineNum">     916 </span><span class="lineCov">         88 :       if(counter_==1+NumWalkers_) //first time only</span></a>
<a name="917"><span class="lineNum">     917 </span>            :       {</a>
<a name="918"><span class="lineNum">     918 </span><span class="lineCov">          6 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="919"><span class="lineNum">     919 </span><span class="lineCov">          4 :           av_M2_[i]*=biasfactor_; //from unbiased, thus must be adjusted</span></a>
<a name="920"><span class="lineNum">     920 </span><span class="lineCov">          6 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="921"><span class="lineNum">     921 </span><span class="lineCov">          4 :           sigma0_[i]=std::sqrt(av_M2_[i]/adaptive_counter_/factor);</span></a>
<a name="922"><span class="lineNum">     922 </span><span class="lineCov">          2 :         if(sigma_min_.size()==0)</span></a>
<a name="923"><span class="lineNum">     923 </span>            :         {</a>
<a name="924"><span class="lineNum">     924 </span><span class="lineCov">          6 :           for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="925"><span class="lineNum">     925 </span><span class="lineCov">          4 :             plumed_massert(sigma0_[i]&gt;1e-6,&quot;ADAPTIVE SIGMA is suspiciously small for CV i=&quot;+std::to_string(i)+&quot;\nManually provide SIGMA or set a safe SIGMA_MIN to avoid possible issues&quot;);</span></a>
<a name="926"><span class="lineNum">     926 </span>            :         }</a>
<a name="927"><span class="lineNum">     927 </span>            :         else</a>
<a name="928"><span class="lineNum">     928 </span>            :         {</a>
<a name="929"><span class="lineNum">     929 </span><span class="lineNoCov">          0 :           for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="930"><span class="lineNum">     930 </span><span class="lineNoCov">          0 :             sigma0_[i]=std::max(sigma0_[i],sigma_min_[i]);</span></a>
<a name="931"><span class="lineNum">     931 </span>            :         }</a>
<a name="932"><span class="lineNum">     932 </span>            :       }</a>
<a name="933"><span class="lineNum">     933 </span><span class="lineCov">        264 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="934"><span class="lineNum">     934 </span><span class="lineCov">        176 :         sigma[i]=std::sqrt(av_M2_[i]/adaptive_counter_/factor);</span></a>
<a name="935"><span class="lineNum">     935 </span><span class="lineCov">         88 :       if(sigma_min_.size()==0)</span></a>
<a name="936"><span class="lineNum">     936 </span>            :       {</a>
<a name="937"><span class="lineNum">     937 </span><span class="lineCov">        114 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="938"><span class="lineNum">     938 </span>            :         {</a>
<a name="939"><span class="lineNum">     939 </span><span class="lineCov">         76 :           if(sigma[i]&lt;1e-6)</span></a>
<a name="940"><span class="lineNum">     940 </span>            :           {</a>
<a name="941"><span class="lineNum">     941 </span><span class="lineNoCov">          0 :             log.printf(&quot;+++ WARNING +++ the ADAPTIVE SIGMA is suspiciously small, you should set a safe SIGMA_MIN. 1e-6 will be used here\n&quot;);</span></a>
<a name="942"><span class="lineNum">     942 </span><span class="lineNoCov">          0 :             sigma[i]=1e-6;</span></a>
<a name="943"><span class="lineNum">     943 </span><span class="lineNoCov">          0 :             sigma_min_.resize(ncv_,1e-6);</span></a>
<a name="944"><span class="lineNum">     944 </span>            :           }</a>
<a name="945"><span class="lineNum">     945 </span>            :         }</a>
<a name="946"><span class="lineNum">     946 </span>            :       }</a>
<a name="947"><span class="lineNum">     947 </span>            :       else</a>
<a name="948"><span class="lineNum">     948 </span>            :       {</a>
<a name="949"><span class="lineNum">     949 </span><span class="lineCov">        150 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="950"><span class="lineNum">     950 </span><span class="lineCov">        100 :           sigma[i]=std::max(sigma[i],sigma_min_[i]);</span></a>
<a name="951"><span class="lineNum">     951 </span>            :       }</a>
<a name="952"><span class="lineNum">     952 </span>            :     }</a>
<a name="953"><span class="lineNum">     953 </span><span class="lineCov">        178 :     if(!fixed_sigma_)</span></a>
<a name="954"><span class="lineNum">     954 </span>            :     {</a>
<a name="955"><span class="lineNum">     955 </span>            :       const double size=neff;</a>
<a name="956"><span class="lineNum">     956 </span><span class="lineCov">        138 :       const double s_rescaling=std::pow(size*(ncv_+2.)/4.,-1./(4+ncv_));</span></a>
<a name="957"><span class="lineNum">     957 </span><span class="lineCov">        414 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="958"><span class="lineNum">     958 </span><span class="lineCov">        276 :         sigma[i]*=s_rescaling;</span></a>
<a name="959"><span class="lineNum">     959 </span><span class="lineCov">        138 :       if(sigma_min_.size()&gt;0)</span></a>
<a name="960"><span class="lineNum">     960 </span>            :       {</a>
<a name="961"><span class="lineNum">     961 </span><span class="lineCov">        150 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="962"><span class="lineNum">     962 </span><span class="lineCov">        100 :           sigma[i]=std::max(sigma[i],sigma_min_[i]);</span></a>
<a name="963"><span class="lineNum">     963 </span>            :       }</a>
<a name="964"><span class="lineNum">     964 </span>            :     }</a>
<a name="965"><span class="lineNum">     965 </span>            :     //the height should be divided by sqrt(2*pi)*sigma0_,</a>
<a name="966"><span class="lineNum">     966 </span>            :     //but this overall factor would be canceled when dividing by Zed</a>
<a name="967"><span class="lineNum">     967 </span>            :     //thus we skip it altogether, but keep any other sigma rescaling</a>
<a name="968"><span class="lineNum">     968 </span><span class="lineCov">        534 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="969"><span class="lineNum">     969 </span><span class="lineCov">        356 :       height*=(sigma0_[i]/sigma[i]);</span></a>
<a name="970"><span class="lineNum">     970 </span>            : </a>
<a name="971"><span class="lineNum">     971 </span>            :     //get new kernel center</a>
<a name="972"><span class="lineNum">     972 </span><span class="lineCov">        178 :     std::vector&lt;double&gt; center(ncv_);</span></a>
<a name="973"><span class="lineNum">     973 </span><span class="lineCov">        534 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="974"><span class="lineNum">     974 </span><span class="lineCov">        356 :       center[i]=getArgument(i);</span></a>
<a name="975"><span class="lineNum">     975 </span>            : </a>
<a name="976"><span class="lineNum">     976 </span>            :     //add new kernel(s)</a>
<a name="977"><span class="lineNum">     977 </span><span class="lineCov">        178 :     if(NumWalkers_==1)</span></a>
<a name="978"><span class="lineNum">     978 </span><span class="lineCov">         90 :       addKernel(height,center,sigma,current_bias_/kbt_);</span></a>
<a name="979"><span class="lineNum">     979 </span>            :     else</a>
<a name="980"><span class="lineNum">     980 </span>            :     {</a>
<a name="981"><span class="lineNum">     981 </span><span class="lineCov">         88 :       std::vector&lt;double&gt; all_height(NumWalkers_,0.0);</span></a>
<a name="982"><span class="lineNum">     982 </span><span class="lineCov">         88 :       std::vector&lt;double&gt; all_center(NumWalkers_*ncv_,0.0);</span></a>
<a name="983"><span class="lineNum">     983 </span><span class="lineCov">         88 :       std::vector&lt;double&gt; all_sigma(NumWalkers_*ncv_,0.0);</span></a>
<a name="984"><span class="lineNum">     984 </span><span class="lineCov">         88 :       std::vector&lt;double&gt; all_logweight(NumWalkers_,0.0);</span></a>
<a name="985"><span class="lineNum">     985 </span><span class="lineCov">         88 :       if(comm.Get_rank()==0)</span></a>
<a name="986"><span class="lineNum">     986 </span>            :       {</a>
<a name="987"><span class="lineNum">     987 </span><span class="lineCov">         88 :         multi_sim_comm.Allgather(height,all_height);</span></a>
<a name="988"><span class="lineNum">     988 </span><span class="lineCov">         88 :         multi_sim_comm.Allgather(center,all_center);</span></a>
<a name="989"><span class="lineNum">     989 </span><span class="lineCov">         88 :         multi_sim_comm.Allgather(sigma,all_sigma);</span></a>
<a name="990"><span class="lineNum">     990 </span><span class="lineCov">         88 :         multi_sim_comm.Allgather(current_bias_/kbt_,all_logweight);</span></a>
<a name="991"><span class="lineNum">     991 </span>            :       }</a>
<a name="992"><span class="lineNum">     992 </span><span class="lineCov">         88 :       comm.Bcast(all_height,0);</span></a>
<a name="993"><span class="lineNum">     993 </span><span class="lineCov">         88 :       comm.Bcast(all_center,0);</span></a>
<a name="994"><span class="lineNum">     994 </span><span class="lineCov">         88 :       comm.Bcast(all_sigma,0);</span></a>
<a name="995"><span class="lineNum">     995 </span><span class="lineCov">         88 :       comm.Bcast(all_logweight,0);</span></a>
<a name="996"><span class="lineNum">     996 </span><span class="lineCov">         88 :       if(nlist_)</span></a>
<a name="997"><span class="lineNum">     997 </span>            :       { //gather all the nlist_index_, so merging can be done using it</a>
<a name="998"><span class="lineNum">     998 </span><span class="lineCov">         50 :         std::vector&lt;int&gt; all_nlist_size(NumWalkers_);</span></a>
<a name="999"><span class="lineNum">     999 </span><span class="lineCov">         50 :         if(comm.Get_rank()==0)</span></a>
<a name="1000"><span class="lineNum">    1000 </span>            :         {</a>
<a name="1001"><span class="lineNum">    1001 </span><span class="lineCov">         50 :           all_nlist_size[walker_rank_]=nlist_index_.size();</span></a>
<a name="1002"><span class="lineNum">    1002 </span><span class="lineCov">         50 :           multi_sim_comm.Sum(all_nlist_size);</span></a>
<a name="1003"><span class="lineNum">    1003 </span>            :         }</a>
<a name="1004"><span class="lineNum">    1004 </span><span class="lineCov">         50 :         comm.Bcast(all_nlist_size,0);</span></a>
<a name="1005"><span class="lineNum">    1005 </span>            :         unsigned tot_size=0;</a>
<a name="1006"><span class="lineNum">    1006 </span><span class="lineCov">        150 :         for(unsigned w=0; w&lt;NumWalkers_; w++)</span></a>
<a name="1007"><span class="lineNum">    1007 </span><span class="lineCov">        100 :           tot_size+=all_nlist_size[w];</span></a>
<a name="1008"><span class="lineNum">    1008 </span><span class="lineCov">         50 :         if(tot_size&gt;0)</span></a>
<a name="1009"><span class="lineNum">    1009 </span>            :         {</a>
<a name="1010"><span class="lineNum">    1010 </span><span class="lineCov">         50 :           std::vector&lt;int&gt; disp(NumWalkers_);</span></a>
<a name="1011"><span class="lineNum">    1011 </span><span class="lineCov">        100 :           for(unsigned w=0; w&lt;NumWalkers_-1; w++)</span></a>
<a name="1012"><span class="lineNum">    1012 </span><span class="lineCov">         50 :             disp[w+1]=disp[w]+all_nlist_size[w];</span></a>
<a name="1013"><span class="lineNum">    1013 </span><span class="lineCov">         50 :           std::vector&lt;unsigned&gt; all_nlist_index(tot_size);</span></a>
<a name="1014"><span class="lineNum">    1014 </span><span class="lineCov">         50 :           if(comm.Get_rank()==0)</span></a>
<a name="1015"><span class="lineNum">    1015 </span><span class="lineCov">         50 :             multi_sim_comm.Allgatherv(nlist_index_,all_nlist_index,&amp;all_nlist_size[0],&amp;disp[0]);</span></a>
<a name="1016"><span class="lineNum">    1016 </span><span class="lineCov">         50 :           comm.Bcast(all_nlist_index,0);</span></a>
<a name="1017"><span class="lineNum">    1017 </span><span class="lineCov">         50 :           std::set&lt;unsigned&gt; nlist_index_set(all_nlist_index.begin(),all_nlist_index.end()); //remove duplicates and sort</span></a>
<a name="1018"><span class="lineNum">    1018 </span><span class="lineCov">         50 :           nlist_index_.assign(nlist_index_set.begin(),nlist_index_set.end());</span></a>
<a name="1019"><span class="lineNum">    1019 </span>            :         }</a>
<a name="1020"><span class="lineNum">    1020 </span>            :       }</a>
<a name="1021"><span class="lineNum">    1021 </span><span class="lineCov">        264 :       for(unsigned w=0; w&lt;NumWalkers_; w++)</span></a>
<a name="1022"><span class="lineNum">    1022 </span>            :       {</a>
<a name="1023"><span class="lineNum">    1023 </span><span class="lineCov">        176 :         std::vector&lt;double&gt; center_w(all_center.begin()+ncv_*w,all_center.begin()+ncv_*(w+1));</span></a>
<a name="1024"><span class="lineNum">    1024 </span><span class="lineCov">        176 :         std::vector&lt;double&gt; sigma_w(all_sigma.begin()+ncv_*w,all_sigma.begin()+ncv_*(w+1));</span></a>
<a name="1025"><span class="lineNum">    1025 </span><span class="lineCov">        176 :         addKernel(all_height[w],center_w,sigma_w,all_logweight[w]);</span></a>
<a name="1026"><span class="lineNum">    1026 </span>            :       }</a>
<a name="1027"><span class="lineNum">    1027 </span>            :     }</a>
<a name="1028"><span class="lineNum">    1028 </span><span class="lineCov">        178 :     getPntrToComponent(&quot;nker&quot;)-&gt;set(kernels_.size());</span></a>
<a name="1029"><span class="lineNum">    1029 </span><span class="lineCov">        178 :     if(nlist_)</span></a>
<a name="1030"><span class="lineNum">    1030 </span>            :     {</a>
<a name="1031"><span class="lineNum">    1031 </span><span class="lineCov">        100 :       getPntrToComponent(&quot;nlker&quot;)-&gt;set(nlist_index_.size());</span></a>
<a name="1032"><span class="lineNum">    1032 </span><span class="lineCov">        100 :       if(nlist_pace_reset_)</span></a>
<a name="1033"><span class="lineNum">    1033 </span><span class="lineCov">         50 :         nlist_update_=true;</span></a>
<a name="1034"><span class="lineNum">    1034 </span>            :     }</a>
<a name="1035"><span class="lineNum">    1035 </span>            : </a>
<a name="1036"><span class="lineNum">    1036 </span>            :     //update Zed_</a>
<a name="1037"><span class="lineNum">    1037 </span><span class="lineCov">        178 :     if(!no_Zed_)</span></a>
<a name="1038"><span class="lineNum">    1038 </span>            :     {</a>
<a name="1039"><span class="lineNum">    1039 </span><span class="lineCov">        138 :       double sum_uprob=0;</span></a>
<a name="1040"><span class="lineNum">    1040 </span><span class="lineCov">        138 :       const unsigned ks=kernels_.size();</span></a>
<a name="1041"><span class="lineNum">    1041 </span><span class="lineCov">        138 :       const unsigned ds=delta_kernels_.size();</span></a>
<a name="1042"><span class="lineNum">    1042 </span><span class="lineCov">        138 :       const bool few_kernels=(ks*ks&lt;(3*ks*ds+2*ds*ds*NumParallel_+100)); //this seems reasonable, but is not rigorous...</span></a>
<a name="1043"><span class="lineNum">    1043 </span><span class="lineCov">        138 :       if(few_kernels) //really needed? Probably is almost always false</span></a>
<a name="1044"><span class="lineNum">    1044 </span>            :       {</a>
<a name="1045"><span class="lineNum">    1045 </span><span class="lineCov">         88 :         #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1046"><span class="lineNum">    1046 </span>            :         {</a>
<a name="1047"><span class="lineNum">    1047 </span>            :           #pragma omp for reduction(+:sum_uprob) nowait</a>
<a name="1048"><span class="lineNum">    1048 </span>            :           for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</a>
<a name="1049"><span class="lineNum">    1049 </span>            :             for(unsigned kk=0; kk&lt;kernels_.size(); kk++)</a>
<a name="1050"><span class="lineNum">    1050 </span>            :               sum_uprob+=evaluateKernel(kernels_[kk],kernels_[k].center);</a>
<a name="1051"><span class="lineNum">    1051 </span>            :         }</a>
<a name="1052"><span class="lineNum">    1052 </span><span class="lineCov">         88 :         if(NumParallel_&gt;1)</span></a>
<a name="1053"><span class="lineNum">    1053 </span><span class="lineCov">         50 :           comm.Sum(sum_uprob);</span></a>
<a name="1054"><span class="lineNum">    1054 </span>            :       }</a>
<a name="1055"><span class="lineNum">    1055 </span>            :       else</a>
<a name="1056"><span class="lineNum">    1056 </span>            :       {</a>
<a name="1057"><span class="lineNum">    1057 </span>            :         // Here instead of redoing the full summation, we add only the changes, knowing that</a>
<a name="1058"><span class="lineNum">    1058 </span>            :         // uprob = old_uprob + delta_uprob</a>
<a name="1059"><span class="lineNum">    1059 </span>            :         // and we also need to consider that in the new sum there are some novel centers and some disappeared ones</a>
<a name="1060"><span class="lineNum">    1060 </span><span class="lineCov">         50 :         double delta_sum_uprob=0;</span></a>
<a name="1061"><span class="lineNum">    1061 </span><span class="lineCov">         50 :         if(!nlist_)</span></a>
<a name="1062"><span class="lineNum">    1062 </span>            :         {</a>
<a name="1063"><span class="lineNum">    1063 </span><span class="lineNoCov">          0 :           #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1064"><span class="lineNum">    1064 </span>            :           {</a>
<a name="1065"><span class="lineNum">    1065 </span>            :             #pragma omp for reduction(+:delta_sum_uprob) nowait</a>
<a name="1066"><span class="lineNum">    1066 </span>            :             for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</a>
<a name="1067"><span class="lineNum">    1067 </span>            :             {</a>
<a name="1068"><span class="lineNum">    1068 </span>            :               for(unsigned d=0; d&lt;delta_kernels_.size(); d++)</a>
<a name="1069"><span class="lineNum">    1069 </span>            :               {</a>
<a name="1070"><span class="lineNum">    1070 </span>            :                 const double sign=delta_kernels_[d].height&lt;0?-1:1; //take away contribution from kernels that are gone, and add the one from new ones</a>
<a name="1071"><span class="lineNum">    1071 </span>            :                 delta_sum_uprob+=evaluateKernel(delta_kernels_[d],kernels_[k].center)+sign*evaluateKernel(kernels_[k],delta_kernels_[d].center);</a>
<a name="1072"><span class="lineNum">    1072 </span>            :               }</a>
<a name="1073"><span class="lineNum">    1073 </span>            :             }</a>
<a name="1074"><span class="lineNum">    1074 </span>            :           }</a>
<a name="1075"><span class="lineNum">    1075 </span>            :         }</a>
<a name="1076"><span class="lineNum">    1076 </span>            :         else</a>
<a name="1077"><span class="lineNum">    1077 </span>            :         {</a>
<a name="1078"><span class="lineNum">    1078 </span><span class="lineCov">         50 :           #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1079"><span class="lineNum">    1079 </span>            :           {</a>
<a name="1080"><span class="lineNum">    1080 </span>            :             #pragma omp for reduction(+:delta_sum_uprob) nowait</a>
<a name="1081"><span class="lineNum">    1081 </span>            :             for(unsigned nk=rank_; nk&lt;nlist_index_.size(); nk+=NumParallel_)</a>
<a name="1082"><span class="lineNum">    1082 </span>            :             {</a>
<a name="1083"><span class="lineNum">    1083 </span>            :               const unsigned k=nlist_index_[nk];</a>
<a name="1084"><span class="lineNum">    1084 </span>            :               for(unsigned d=0; d&lt;delta_kernels_.size(); d++)</a>
<a name="1085"><span class="lineNum">    1085 </span>            :               {</a>
<a name="1086"><span class="lineNum">    1086 </span>            :                 const double sign=delta_kernels_[d].height&lt;0?-1:1; //take away contribution from kernels that are gone, and add the one from new ones</a>
<a name="1087"><span class="lineNum">    1087 </span>            :                 delta_sum_uprob+=evaluateKernel(delta_kernels_[d],kernels_[k].center)+sign*evaluateKernel(kernels_[k],delta_kernels_[d].center);</a>
<a name="1088"><span class="lineNum">    1088 </span>            :               }</a>
<a name="1089"><span class="lineNum">    1089 </span>            :             }</a>
<a name="1090"><span class="lineNum">    1090 </span>            :           }</a>
<a name="1091"><span class="lineNum">    1091 </span>            :         }</a>
<a name="1092"><span class="lineNum">    1092 </span><span class="lineCov">         50 :         if(NumParallel_&gt;1)</span></a>
<a name="1093"><span class="lineNum">    1093 </span><span class="lineNoCov">          0 :           comm.Sum(delta_sum_uprob);</span></a>
<a name="1094"><span class="lineNum">    1094 </span><span class="lineCov">         50 :         #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1095"><span class="lineNum">    1095 </span>            :         {</a>
<a name="1096"><span class="lineNum">    1096 </span>            :           #pragma omp for reduction(+:delta_sum_uprob)</a>
<a name="1097"><span class="lineNum">    1097 </span>            :           for(unsigned d=0; d&lt;delta_kernels_.size(); d++)</a>
<a name="1098"><span class="lineNum">    1098 </span>            :           {</a>
<a name="1099"><span class="lineNum">    1099 </span>            :             for(unsigned dd=0; dd&lt;delta_kernels_.size(); dd++)</a>
<a name="1100"><span class="lineNum">    1100 </span>            :             { //now subtract the delta_uprob added before, but not needed</a>
<a name="1101"><span class="lineNum">    1101 </span>            :               const double sign=delta_kernels_[d].height&lt;0?-1:1;</a>
<a name="1102"><span class="lineNum">    1102 </span>            :               delta_sum_uprob-=sign*evaluateKernel(delta_kernels_[dd],delta_kernels_[d].center);</a>
<a name="1103"><span class="lineNum">    1103 </span>            :             }</a>
<a name="1104"><span class="lineNum">    1104 </span>            :           }</a>
<a name="1105"><span class="lineNum">    1105 </span>            :         }</a>
<a name="1106"><span class="lineNum">    1106 </span><span class="lineCov">         50 :         sum_uprob=Zed_*old_KDEnorm_*old_nker+delta_sum_uprob;</span></a>
<a name="1107"><span class="lineNum">    1107 </span>            :       }</a>
<a name="1108"><span class="lineNum">    1108 </span><span class="lineCov">        138 :       Zed_=sum_uprob/KDEnorm_/kernels_.size();</span></a>
<a name="1109"><span class="lineNum">    1109 </span><span class="lineCov">        276 :       getPntrToComponent(&quot;zed&quot;)-&gt;set(Zed_);</span></a>
<a name="1110"><span class="lineNum">    1110 </span>            :     }</a>
<a name="1111"><span class="lineNum">    1111 </span>            : </a>
<a name="1112"><span class="lineNum">    1112 </span>            :     //calculate work if requested</a>
<a name="1113"><span class="lineNum">    1113 </span><span class="lineCov">        178 :     if(calc_work_)</span></a>
<a name="1114"><span class="lineNum">    1114 </span>            :     {</a>
<a name="1115"><span class="lineNum">    1115 </span><span class="lineCov">         40 :       std::vector&lt;double&gt; dummy(ncv_); //derivatives are not actually needed</span></a>
<a name="1116"><span class="lineNum">    1116 </span><span class="lineCov">         40 :       const double prob=getProbAndDerivatives(center,dummy);</span></a>
<a name="1117"><span class="lineNum">    1117 </span><span class="lineCov">         40 :       const double new_bias=kbt_*bias_prefactor_*std::log(prob/Zed_+epsilon_);</span></a>
<a name="1118"><span class="lineNum">    1118 </span><span class="lineCov">         40 :       work_+=new_bias-current_bias_;</span></a>
<a name="1119"><span class="lineNum">    1119 </span><span class="lineCov">         80 :       getPntrToComponent(&quot;work&quot;)-&gt;set(work_);</span></a>
<a name="1120"><span class="lineNum">    1120 </span>            :     }</a>
<a name="1121"><span class="lineNum">    1121 </span>            :   }</a>
<a name="1122"><span class="lineNum">    1122 </span>            : </a>
<a name="1123"><span class="lineNum">    1123 </span>            : //dump state if requested</a>
<a name="1124"><span class="lineNum">    1124 </span><span class="lineCov">        582 :   if( (wStateStride_&gt;0 &amp;&amp; getStep()%wStateStride_==0) || (wStateStride_==-1 &amp;&amp; getCPT()) )</span></a>
<a name="1125"><span class="lineNum">    1125 </span><span class="lineCov">         10 :     dumpStateToFile();</span></a>
<a name="1126"><span class="lineNum">    1126 </span>            : }</a>
<a name="1127"><span class="lineNum">    1127 </span>            : </a>
<a name="1128"><span class="lineNum">    1128 </span><span class="lineCov">        652 : double OPESmetad::getProbAndDerivatives(const std::vector&lt;double&gt;&amp; cv,std::vector&lt;double&gt;&amp; der_prob)</span></a>
<a name="1129"><span class="lineNum">    1129 </span>            : {</a>
<a name="1130"><span class="lineNum">    1130 </span><span class="lineCov">        652 :   double prob=0.0;</span></a>
<a name="1131"><span class="lineNum">    1131 </span><span class="lineCov">        652 :   if(!nlist_)</span></a>
<a name="1132"><span class="lineNum">    1132 </span>            :   {</a>
<a name="1133"><span class="lineNum">    1133 </span><span class="lineCov">        448 :     if(NumOMP_==1 || (unsigned)kernels_.size()&lt;2*NumOMP_*NumParallel_)</span></a>
<a name="1134"><span class="lineNum">    1134 </span>            :     {</a>
<a name="1135"><span class="lineNum">    1135 </span>            :       // for performances and thread safety</a>
<a name="1136"><span class="lineNum">    1136 </span><span class="lineCov">        306 :       std::vector&lt;double&gt; dist(ncv_);</span></a>
<a name="1137"><span class="lineNum">    1137 </span><span class="lineCov">       2156 :       for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</span></a>
<a name="1138"><span class="lineNum">    1138 </span><span class="lineCov">       1850 :         prob+=evaluateKernel(kernels_[k],cv,der_prob,dist);</span></a>
<a name="1139"><span class="lineNum">    1139 </span>            :     }</a>
<a name="1140"><span class="lineNum">    1140 </span>            :     else</a>
<a name="1141"><span class="lineNum">    1141 </span>            :     {</a>
<a name="1142"><span class="lineNum">    1142 </span><span class="lineCov">        142 :       #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1143"><span class="lineNum">    1143 </span>            :       {</a>
<a name="1144"><span class="lineNum">    1144 </span>            :         std::vector&lt;double&gt; omp_deriv(der_prob.size(),0.);</a>
<a name="1145"><span class="lineNum">    1145 </span>            :         // for performances and thread safety</a>
<a name="1146"><span class="lineNum">    1146 </span>            :         std::vector&lt;double&gt; dist(ncv_);</a>
<a name="1147"><span class="lineNum">    1147 </span>            :         #pragma omp for reduction(+:prob) nowait</a>
<a name="1148"><span class="lineNum">    1148 </span>            :         for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</a>
<a name="1149"><span class="lineNum">    1149 </span>            :           prob+=evaluateKernel(kernels_[k],cv,omp_deriv,dist);</a>
<a name="1150"><span class="lineNum">    1150 </span>            :         #pragma omp critical</a>
<a name="1151"><span class="lineNum">    1151 </span>            :         for(unsigned i=0; i&lt;ncv_; i++)</a>
<a name="1152"><span class="lineNum">    1152 </span>            :           der_prob[i]+=omp_deriv[i];</a>
<a name="1153"><span class="lineNum">    1153 </span>            :       }</a>
<a name="1154"><span class="lineNum">    1154 </span>            :     }</a>
<a name="1155"><span class="lineNum">    1155 </span>            :   }</a>
<a name="1156"><span class="lineNum">    1156 </span>            :   else</a>
<a name="1157"><span class="lineNum">    1157 </span>            :   {</a>
<a name="1158"><span class="lineNum">    1158 </span><span class="lineCov">        204 :     if(NumOMP_==1 || (unsigned)nlist_index_.size()&lt;2*NumOMP_*NumParallel_)</span></a>
<a name="1159"><span class="lineNum">    1159 </span>            :     {</a>
<a name="1160"><span class="lineNum">    1160 </span>            :       // for performances and thread safety</a>
<a name="1161"><span class="lineNum">    1161 </span><span class="lineCov">        180 :       std::vector&lt;double&gt; dist(ncv_);</span></a>
<a name="1162"><span class="lineNum">    1162 </span><span class="lineCov">        545 :       for(unsigned nk=rank_; nk&lt;nlist_index_.size(); nk+=NumParallel_)</span></a>
<a name="1163"><span class="lineNum">    1163 </span><span class="lineCov">        365 :         prob+=evaluateKernel(kernels_[nlist_index_[nk]],cv,der_prob,dist);</span></a>
<a name="1164"><span class="lineNum">    1164 </span>            :     }</a>
<a name="1165"><span class="lineNum">    1165 </span>            :     else</a>
<a name="1166"><span class="lineNum">    1166 </span>            :     {</a>
<a name="1167"><span class="lineNum">    1167 </span><span class="lineCov">         24 :       #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1168"><span class="lineNum">    1168 </span>            :       {</a>
<a name="1169"><span class="lineNum">    1169 </span>            :         std::vector&lt;double&gt; omp_deriv(der_prob.size(),0.);</a>
<a name="1170"><span class="lineNum">    1170 </span>            :         // for performances and thread safety</a>
<a name="1171"><span class="lineNum">    1171 </span>            :         std::vector&lt;double&gt; dist(ncv_);</a>
<a name="1172"><span class="lineNum">    1172 </span>            :         #pragma omp for reduction(+:prob) nowait</a>
<a name="1173"><span class="lineNum">    1173 </span>            :         for(unsigned nk=rank_; nk&lt;nlist_index_.size(); nk+=NumParallel_)</a>
<a name="1174"><span class="lineNum">    1174 </span>            :           prob+=evaluateKernel(kernels_[nlist_index_[nk]],cv,omp_deriv,dist);</a>
<a name="1175"><span class="lineNum">    1175 </span>            :         #pragma omp critical</a>
<a name="1176"><span class="lineNum">    1176 </span>            :         for(unsigned i=0; i&lt;ncv_; i++)</a>
<a name="1177"><span class="lineNum">    1177 </span>            :           der_prob[i]+=omp_deriv[i];</a>
<a name="1178"><span class="lineNum">    1178 </span>            :       }</a>
<a name="1179"><span class="lineNum">    1179 </span>            :     }</a>
<a name="1180"><span class="lineNum">    1180 </span>            :   }</a>
<a name="1181"><span class="lineNum">    1181 </span><span class="lineCov">        652 :   if(NumParallel_&gt;1)</span></a>
<a name="1182"><span class="lineNum">    1182 </span>            :   {</a>
<a name="1183"><span class="lineNum">    1183 </span><span class="lineCov">        102 :     comm.Sum(prob);</span></a>
<a name="1184"><span class="lineNum">    1184 </span><span class="lineCov">        102 :     comm.Sum(der_prob);</span></a>
<a name="1185"><span class="lineNum">    1185 </span>            :   }</a>
<a name="1186"><span class="lineNum">    1186 </span>            : //normalize the estimate</a>
<a name="1187"><span class="lineNum">    1187 </span><span class="lineCov">        652 :   prob/=KDEnorm_;</span></a>
<a name="1188"><span class="lineNum">    1188 </span><span class="lineCov">       1956 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1189"><span class="lineNum">    1189 </span><span class="lineCov">       1304 :     der_prob[i]/=KDEnorm_;</span></a>
<a name="1190"><span class="lineNum">    1190 </span>            : </a>
<a name="1191"><span class="lineNum">    1191 </span><span class="lineCov">        652 :   return prob;</span></a>
<a name="1192"><span class="lineNum">    1192 </span>            : }</a>
<a name="1193"><span class="lineNum">    1193 </span>            : </a>
<a name="1194"><span class="lineNum">    1194 </span><span class="lineCov">        386 : void OPESmetad::addKernel(const double height,const std::vector&lt;double&gt;&amp; center,const std::vector&lt;double&gt;&amp; sigma)</span></a>
<a name="1195"><span class="lineNum">    1195 </span>            : {</a>
<a name="1196"><span class="lineNum">    1196 </span>            :   bool no_match=true;</a>
<a name="1197"><span class="lineNum">    1197 </span><span class="lineCov">        386 :   if(threshold2_!=0)</span></a>
<a name="1198"><span class="lineNum">    1198 </span>            :   {</a>
<a name="1199"><span class="lineNum">    1199 </span><span class="lineCov">        386 :     unsigned taker_k=getMergeableKernel(center,kernels_.size());</span></a>
<a name="1200"><span class="lineNum">    1200 </span><span class="lineCov">        386 :     if(taker_k&lt;kernels_.size())</span></a>
<a name="1201"><span class="lineNum">    1201 </span>            :     {</a>
<a name="1202"><span class="lineNum">    1202 </span>            :       no_match=false;</a>
<a name="1203"><span class="lineNum">    1203 </span><span class="lineCov">        282 :       delta_kernels_.emplace_back(-1*kernels_[taker_k].height,kernels_[taker_k].center,kernels_[taker_k].sigma);</span></a>
<a name="1204"><span class="lineNum">    1204 </span><span class="lineCov">        282 :       mergeKernels(kernels_[taker_k],kernel(height,center,sigma));</span></a>
<a name="1205"><span class="lineNum">    1205 </span><span class="lineCov">        282 :       delta_kernels_.push_back(kernels_[taker_k]);</span></a>
<a name="1206"><span class="lineNum">    1206 </span><span class="lineCov">        282 :       if(recursive_merge_) //the overhead is worth it if it keeps low the total number of kernels</span></a>
<a name="1207"><span class="lineNum">    1207 </span>            :       {</a>
<a name="1208"><span class="lineNum">    1208 </span>            :         unsigned giver_k=taker_k;</a>
<a name="1209"><span class="lineNum">    1209 </span><span class="lineCov">        262 :         taker_k=getMergeableKernel(kernels_[giver_k].center,giver_k);</span></a>
<a name="1210"><span class="lineNum">    1210 </span><span class="lineCov">        262 :         while(taker_k&lt;kernels_.size())</span></a>
<a name="1211"><span class="lineNum">    1211 </span>            :         {</a>
<a name="1212"><span class="lineNum">    1212 </span>            :           delta_kernels_.pop_back();</a>
<a name="1213"><span class="lineNum">    1213 </span><span class="lineNoCov">          0 :           delta_kernels_.emplace_back(-1*kernels_[taker_k].height,kernels_[taker_k].center,kernels_[taker_k].sigma);</span></a>
<a name="1214"><span class="lineNum">    1214 </span><span class="lineNoCov">          0 :           if(taker_k&gt;giver_k) //saves time when erasing</span></a>
<a name="1215"><span class="lineNum">    1215 </span>            :             std::swap(taker_k,giver_k);</a>
<a name="1216"><span class="lineNum">    1216 </span><span class="lineNoCov">          0 :           mergeKernels(kernels_[taker_k],kernels_[giver_k]);</span></a>
<a name="1217"><span class="lineNum">    1217 </span><span class="lineNoCov">          0 :           delta_kernels_.push_back(kernels_[taker_k]);</span></a>
<a name="1218"><span class="lineNum">    1218 </span><span class="lineNoCov">          0 :           kernels_.erase(kernels_.begin()+giver_k);</span></a>
<a name="1219"><span class="lineNum">    1219 </span><span class="lineNoCov">          0 :           if(nlist_)</span></a>
<a name="1220"><span class="lineNum">    1220 </span>            :           {</a>
<a name="1221"><span class="lineNum">    1221 </span>            :             unsigned giver_nk=0;</a>
<a name="1222"><span class="lineNum">    1222 </span>            :             bool found_giver=false;</a>
<a name="1223"><span class="lineNum">    1223 </span><span class="lineNoCov">          0 :             for(unsigned nk=0; nk&lt;nlist_index_.size(); nk++)</span></a>
<a name="1224"><span class="lineNum">    1224 </span>            :             {</a>
<a name="1225"><span class="lineNum">    1225 </span><span class="lineNoCov">          0 :               if(found_giver)</span></a>
<a name="1226"><span class="lineNum">    1226 </span><span class="lineNoCov">          0 :                 nlist_index_[nk]--; //all the indexes shift due to erase</span></a>
<a name="1227"><span class="lineNum">    1227 </span><span class="lineNoCov">          0 :               if(nlist_index_[nk]==giver_k)</span></a>
<a name="1228"><span class="lineNum">    1228 </span>            :               {</a>
<a name="1229"><span class="lineNum">    1229 </span>            :                 giver_nk=nk;</a>
<a name="1230"><span class="lineNum">    1230 </span>            :                 found_giver=true;</a>
<a name="1231"><span class="lineNum">    1231 </span>            :               }</a>
<a name="1232"><span class="lineNum">    1232 </span>            :             }</a>
<a name="1233"><span class="lineNum">    1233 </span>            :             plumed_dbg_massert(found_giver,&quot;problem with merging and NLIST&quot;);</a>
<a name="1234"><span class="lineNum">    1234 </span><span class="lineNoCov">          0 :             nlist_index_.erase(nlist_index_.begin()+giver_nk);</span></a>
<a name="1235"><span class="lineNum">    1235 </span>            :           }</a>
<a name="1236"><span class="lineNum">    1236 </span>            :           giver_k=taker_k;</a>
<a name="1237"><span class="lineNum">    1237 </span><span class="lineNoCov">          0 :           taker_k=getMergeableKernel(kernels_[giver_k].center,giver_k);</span></a>
<a name="1238"><span class="lineNum">    1238 </span>            :         }</a>
<a name="1239"><span class="lineNum">    1239 </span>            :       }</a>
<a name="1240"><span class="lineNum">    1240 </span>            :     }</a>
<a name="1241"><span class="lineNum">    1241 </span>            :   }</a>
<a name="1242"><span class="lineNum">    1242 </span>            :   if(no_match)</a>
<a name="1243"><span class="lineNum">    1243 </span>            :   {</a>
<a name="1244"><span class="lineNum">    1244 </span><span class="lineCov">        104 :     kernels_.emplace_back(height,center,sigma);</span></a>
<a name="1245"><span class="lineNum">    1245 </span><span class="lineCov">        104 :     delta_kernels_.emplace_back(height,center,sigma);</span></a>
<a name="1246"><span class="lineNum">    1246 </span><span class="lineCov">        104 :     if(nlist_)</span></a>
<a name="1247"><span class="lineNum">    1247 </span><span class="lineCov">          6 :       nlist_index_.push_back(kernels_.size()-1);</span></a>
<a name="1248"><span class="lineNum">    1248 </span>            :   }</a>
<a name="1249"><span class="lineNum">    1249 </span><span class="lineCov">        386 : }</span></a>
<a name="1250"><span class="lineNum">    1250 </span>            : </a>
<a name="1251"><span class="lineNum">    1251 </span><span class="lineCov">        266 : void OPESmetad::addKernel(const double height,const std::vector&lt;double&gt;&amp; center,const std::vector&lt;double&gt;&amp; sigma,const double logweight)</span></a>
<a name="1252"><span class="lineNum">    1252 </span>            : {</a>
<a name="1253"><span class="lineNum">    1253 </span><span class="lineCov">        266 :   addKernel(height,center,sigma);</span></a>
<a name="1254"><span class="lineNum">    1254 </span>            : //write to file</a>
<a name="1255"><span class="lineNum">    1255 </span><span class="lineCov">        532 :   kernelsOfile_.printField(&quot;time&quot;,getTime());</span></a>
<a name="1256"><span class="lineNum">    1256 </span><span class="lineCov">        798 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1257"><span class="lineNum">    1257 </span><span class="lineCov">        532 :     kernelsOfile_.printField(getPntrToArgument(i),center[i]);</span></a>
<a name="1258"><span class="lineNum">    1258 </span><span class="lineCov">        798 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1259"><span class="lineNum">    1259 </span><span class="lineCov">       1064 :     kernelsOfile_.printField(&quot;sigma_&quot;+getPntrToArgument(i)-&gt;getName(),sigma[i]);</span></a>
<a name="1260"><span class="lineNum">    1260 </span><span class="lineCov">        266 :   kernelsOfile_.printField(&quot;height&quot;,height);</span></a>
<a name="1261"><span class="lineNum">    1261 </span><span class="lineCov">        266 :   kernelsOfile_.printField(&quot;logweight&quot;,logweight);</span></a>
<a name="1262"><span class="lineNum">    1262 </span><span class="lineCov">        266 :   kernelsOfile_.printField();</span></a>
<a name="1263"><span class="lineNum">    1263 </span><span class="lineCov">        266 : }</span></a>
<a name="1264"><span class="lineNum">    1264 </span>            : </a>
<a name="1265"><span class="lineNum">    1265 </span><span class="lineCov">        648 : unsigned OPESmetad::getMergeableKernel(const std::vector&lt;double&gt;&amp; giver_center,const unsigned giver_k)</span></a>
<a name="1266"><span class="lineNum">    1266 </span>            : { //returns kernels_.size() if no match is found</a>
<a name="1267"><span class="lineNum">    1267 </span><span class="lineCov">        648 :   unsigned min_k=kernels_.size();</span></a>
<a name="1268"><span class="lineNum">    1268 </span><span class="lineCov">        648 :   double min_norm2=threshold2_;</span></a>
<a name="1269"><span class="lineNum">    1269 </span><span class="lineCov">        648 :   if(!nlist_)</span></a>
<a name="1270"><span class="lineNum">    1270 </span>            :   {</a>
<a name="1271"><span class="lineNum">    1271 </span><span class="lineCov">        354 :     #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1272"><span class="lineNum">    1272 </span>            :     {</a>
<a name="1273"><span class="lineNum">    1273 </span>            :       unsigned min_k_omp = min_k;</a>
<a name="1274"><span class="lineNum">    1274 </span>            :       double min_norm2_omp = threshold2_;</a>
<a name="1275"><span class="lineNum">    1275 </span>            :       #pragma omp for nowait</a>
<a name="1276"><span class="lineNum">    1276 </span>            :       for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</a>
<a name="1277"><span class="lineNum">    1277 </span>            :       {</a>
<a name="1278"><span class="lineNum">    1278 </span>            :         if(k==giver_k) //a kernel should not be merged with itself</a>
<a name="1279"><span class="lineNum">    1279 </span>            :           continue;</a>
<a name="1280"><span class="lineNum">    1280 </span>            :         double norm2=0;</a>
<a name="1281"><span class="lineNum">    1281 </span>            :         for(unsigned i=0; i&lt;ncv_; i++)</a>
<a name="1282"><span class="lineNum">    1282 </span>            :         {</a>
<a name="1283"><span class="lineNum">    1283 </span>            :           const double dist_i=difference(i,giver_center[i],kernels_[k].center[i])/kernels_[k].sigma[i];</a>
<a name="1284"><span class="lineNum">    1284 </span>            :           norm2+=dist_i*dist_i;</a>
<a name="1285"><span class="lineNum">    1285 </span>            :           if(norm2&gt;=min_norm2_omp)</a>
<a name="1286"><span class="lineNum">    1286 </span>            :             break;</a>
<a name="1287"><span class="lineNum">    1287 </span>            :         }</a>
<a name="1288"><span class="lineNum">    1288 </span>            :         if(norm2&lt;min_norm2_omp)</a>
<a name="1289"><span class="lineNum">    1289 </span>            :         {</a>
<a name="1290"><span class="lineNum">    1290 </span>            :           min_norm2_omp=norm2;</a>
<a name="1291"><span class="lineNum">    1291 </span>            :           min_k_omp=k;</a>
<a name="1292"><span class="lineNum">    1292 </span>            :         }</a>
<a name="1293"><span class="lineNum">    1293 </span>            :       }</a>
<a name="1294"><span class="lineNum">    1294 </span>            :       #pragma omp critical</a>
<a name="1295"><span class="lineNum">    1295 </span>            :       {</a>
<a name="1296"><span class="lineNum">    1296 </span>            :         if(min_norm2_omp &lt; min_norm2)</a>
<a name="1297"><span class="lineNum">    1297 </span>            :         {</a>
<a name="1298"><span class="lineNum">    1298 </span>            :           min_norm2 = min_norm2_omp;</a>
<a name="1299"><span class="lineNum">    1299 </span>            :           min_k = min_k_omp;</a>
<a name="1300"><span class="lineNum">    1300 </span>            :         }</a>
<a name="1301"><span class="lineNum">    1301 </span>            :       }</a>
<a name="1302"><span class="lineNum">    1302 </span>            :     }</a>
<a name="1303"><span class="lineNum">    1303 </span>            :   }</a>
<a name="1304"><span class="lineNum">    1304 </span>            :   else</a>
<a name="1305"><span class="lineNum">    1305 </span>            :   {</a>
<a name="1306"><span class="lineNum">    1306 </span><span class="lineCov">        294 :     #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1307"><span class="lineNum">    1307 </span>            :     {</a>
<a name="1308"><span class="lineNum">    1308 </span>            :       unsigned min_k_omp = min_k;</a>
<a name="1309"><span class="lineNum">    1309 </span>            :       double min_norm2_omp = threshold2_;</a>
<a name="1310"><span class="lineNum">    1310 </span>            :       #pragma omp for nowait</a>
<a name="1311"><span class="lineNum">    1311 </span>            :       for(unsigned nk=rank_; nk&lt;nlist_index_.size(); nk+=NumParallel_)</a>
<a name="1312"><span class="lineNum">    1312 </span>            :       {</a>
<a name="1313"><span class="lineNum">    1313 </span>            :         const unsigned k=nlist_index_[nk];</a>
<a name="1314"><span class="lineNum">    1314 </span>            :         if(k==giver_k) //a kernel should not be merged with itself</a>
<a name="1315"><span class="lineNum">    1315 </span>            :           continue;</a>
<a name="1316"><span class="lineNum">    1316 </span>            :         double norm2=0;</a>
<a name="1317"><span class="lineNum">    1317 </span>            :         for(unsigned i=0; i&lt;ncv_; i++)</a>
<a name="1318"><span class="lineNum">    1318 </span>            :         {</a>
<a name="1319"><span class="lineNum">    1319 </span>            :           const double dist_i=difference(i,giver_center[i],kernels_[k].center[i])/kernels_[k].sigma[i];</a>
<a name="1320"><span class="lineNum">    1320 </span>            :           norm2+=dist_i*dist_i;</a>
<a name="1321"><span class="lineNum">    1321 </span>            :           if(norm2&gt;=min_norm2)</a>
<a name="1322"><span class="lineNum">    1322 </span>            :             break;</a>
<a name="1323"><span class="lineNum">    1323 </span>            :         }</a>
<a name="1324"><span class="lineNum">    1324 </span>            :         if(norm2&lt;min_norm2_omp)</a>
<a name="1325"><span class="lineNum">    1325 </span>            :         {</a>
<a name="1326"><span class="lineNum">    1326 </span>            :           min_norm2_omp=norm2;</a>
<a name="1327"><span class="lineNum">    1327 </span>            :           min_k_omp=k;</a>
<a name="1328"><span class="lineNum">    1328 </span>            :         }</a>
<a name="1329"><span class="lineNum">    1329 </span>            :       }</a>
<a name="1330"><span class="lineNum">    1330 </span>            :       #pragma omp critical</a>
<a name="1331"><span class="lineNum">    1331 </span>            :       {</a>
<a name="1332"><span class="lineNum">    1332 </span>            :         if(min_norm2_omp &lt; min_norm2)</a>
<a name="1333"><span class="lineNum">    1333 </span>            :         {</a>
<a name="1334"><span class="lineNum">    1334 </span>            :           min_norm2 = min_norm2_omp;</a>
<a name="1335"><span class="lineNum">    1335 </span>            :           min_k = min_k_omp;</a>
<a name="1336"><span class="lineNum">    1336 </span>            :         }</a>
<a name="1337"><span class="lineNum">    1337 </span>            :       }</a>
<a name="1338"><span class="lineNum">    1338 </span>            :     }</a>
<a name="1339"><span class="lineNum">    1339 </span>            :   }</a>
<a name="1340"><span class="lineNum">    1340 </span><span class="lineCov">        648 :   if(NumParallel_&gt;1)</span></a>
<a name="1341"><span class="lineNum">    1341 </span>            :   {</a>
<a name="1342"><span class="lineNum">    1342 </span><span class="lineCov">         94 :     std::vector&lt;double&gt; all_min_norm2(NumParallel_);</span></a>
<a name="1343"><span class="lineNum">    1343 </span><span class="lineCov">         94 :     std::vector&lt;unsigned&gt; all_min_k(NumParallel_);</span></a>
<a name="1344"><span class="lineNum">    1344 </span><span class="lineCov">         94 :     comm.Allgather(min_norm2,all_min_norm2);</span></a>
<a name="1345"><span class="lineNum">    1345 </span><span class="lineCov">         94 :     comm.Allgather(min_k,all_min_k);</span></a>
<a name="1346"><span class="lineNum">    1346 </span><span class="lineCov">         94 :     const unsigned best=std::distance(std::begin(all_min_norm2),std::min_element(std::begin(all_min_norm2),std::end(all_min_norm2)));</span></a>
<a name="1347"><span class="lineNum">    1347 </span><span class="lineCov">         94 :     min_k=all_min_k[best];</span></a>
<a name="1348"><span class="lineNum">    1348 </span>            :   }</a>
<a name="1349"><span class="lineNum">    1349 </span><span class="lineCov">        648 :   return min_k;</span></a>
<a name="1350"><span class="lineNum">    1350 </span>            : }</a>
<a name="1351"><span class="lineNum">    1351 </span>            : </a>
<a name="1352"><span class="lineNum">    1352 </span><span class="lineCov">        202 : void OPESmetad::updateNlist(const std::vector&lt;double&gt;&amp; new_center)</span></a>
<a name="1353"><span class="lineNum">    1353 </span>            : {</a>
<a name="1354"><span class="lineNum">    1354 </span><span class="lineCov">        202 :   if(kernels_.size()==0) //no need to check for neighbors</span></a>
<a name="1355"><span class="lineNum">    1355 </span><span class="lineNoCov">          0 :     return;</span></a>
<a name="1356"><span class="lineNum">    1356 </span>            : </a>
<a name="1357"><span class="lineNum">    1357 </span><span class="lineCov">        202 :   nlist_center_=new_center;</span></a>
<a name="1358"><span class="lineNum">    1358 </span><span class="lineCov">        202 :   nlist_index_.clear();</span></a>
<a name="1359"><span class="lineNum">    1359 </span>            :   //first we gather all the nlist_index</a>
<a name="1360"><span class="lineNum">    1360 </span><span class="lineCov">        202 :   if(NumOMP_==1 || (unsigned)kernels_.size()&lt;2*NumOMP_*NumParallel_)</span></a>
<a name="1361"><span class="lineNum">    1361 </span>            :   {</a>
<a name="1362"><span class="lineNum">    1362 </span><span class="lineCov">        157 :     for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</span></a>
<a name="1363"><span class="lineNum">    1363 </span>            :     {</a>
<a name="1364"><span class="lineNum">    1364 </span>            :       double norm2_k=0;</a>
<a name="1365"><span class="lineNum">    1365 </span><span class="lineCov">        363 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1366"><span class="lineNum">    1366 </span>            :       {</a>
<a name="1367"><span class="lineNum">    1367 </span><span class="lineCov">        242 :         const double dist_ik=difference(i,nlist_center_[i],kernels_[k].center[i])/kernels_[k].sigma[i];</span></a>
<a name="1368"><span class="lineNum">    1368 </span><span class="lineCov">        242 :         norm2_k+=dist_ik*dist_ik;</span></a>
<a name="1369"><span class="lineNum">    1369 </span>            :       }</a>
<a name="1370"><span class="lineNum">    1370 </span><span class="lineCov">        121 :       if(norm2_k&lt;=nlist_param_[0]*cutoff2_)</span></a>
<a name="1371"><span class="lineNum">    1371 </span><span class="lineCov">         85 :         nlist_index_.push_back(k);</span></a>
<a name="1372"><span class="lineNum">    1372 </span>            :     }</a>
<a name="1373"><span class="lineNum">    1373 </span>            :   }</a>
<a name="1374"><span class="lineNum">    1374 </span>            :   else</a>
<a name="1375"><span class="lineNum">    1375 </span>            :   {</a>
<a name="1376"><span class="lineNum">    1376 </span><span class="lineCov">        166 :     #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1377"><span class="lineNum">    1377 </span>            :     {</a>
<a name="1378"><span class="lineNum">    1378 </span>            :       std::vector&lt;unsigned&gt; private_nlist_index;</a>
<a name="1379"><span class="lineNum">    1379 </span>            :       #pragma omp for nowait</a>
<a name="1380"><span class="lineNum">    1380 </span>            :       for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</a>
<a name="1381"><span class="lineNum">    1381 </span>            :       {</a>
<a name="1382"><span class="lineNum">    1382 </span>            :         double norm2_k=0;</a>
<a name="1383"><span class="lineNum">    1383 </span>            :         for(unsigned i=0; i&lt;ncv_; i++)</a>
<a name="1384"><span class="lineNum">    1384 </span>            :         {</a>
<a name="1385"><span class="lineNum">    1385 </span>            :           const double dist_ik=difference(i,nlist_center_[i],kernels_[k].center[i])/kernels_[k].sigma[i];</a>
<a name="1386"><span class="lineNum">    1386 </span>            :           norm2_k+=dist_ik*dist_ik;</a>
<a name="1387"><span class="lineNum">    1387 </span>            :         }</a>
<a name="1388"><span class="lineNum">    1388 </span>            :         if(norm2_k&lt;=nlist_param_[0]*cutoff2_)</a>
<a name="1389"><span class="lineNum">    1389 </span>            :           private_nlist_index.push_back(k);</a>
<a name="1390"><span class="lineNum">    1390 </span>            :       }</a>
<a name="1391"><span class="lineNum">    1391 </span>            :       #pragma omp critical</a>
<a name="1392"><span class="lineNum">    1392 </span>            :       nlist_index_.insert(nlist_index_.end(),private_nlist_index.begin(),private_nlist_index.end());</a>
<a name="1393"><span class="lineNum">    1393 </span>            :     }</a>
<a name="1394"><span class="lineNum">    1394 </span><span class="lineCov">        166 :     if(recursive_merge_)</span></a>
<a name="1395"><span class="lineNum">    1395 </span><span class="lineCov">        166 :       std::sort(nlist_index_.begin(),nlist_index_.end());</span></a>
<a name="1396"><span class="lineNum">    1396 </span>            :   }</a>
<a name="1397"><span class="lineNum">    1397 </span><span class="lineCov">        202 :   if(NumParallel_&gt;1)</span></a>
<a name="1398"><span class="lineNum">    1398 </span>            :   {</a>
<a name="1399"><span class="lineNum">    1399 </span><span class="lineCov">        100 :     std::vector&lt;int&gt; all_nlist_size(NumParallel_);</span></a>
<a name="1400"><span class="lineNum">    1400 </span><span class="lineCov">        100 :     all_nlist_size[rank_]=nlist_index_.size();</span></a>
<a name="1401"><span class="lineNum">    1401 </span><span class="lineCov">        100 :     comm.Sum(all_nlist_size);</span></a>
<a name="1402"><span class="lineNum">    1402 </span>            :     unsigned tot_size=0;</a>
<a name="1403"><span class="lineNum">    1403 </span><span class="lineCov">        300 :     for(unsigned r=0; r&lt;NumParallel_; r++)</span></a>
<a name="1404"><span class="lineNum">    1404 </span><span class="lineCov">        200 :       tot_size+=all_nlist_size[r];</span></a>
<a name="1405"><span class="lineNum">    1405 </span><span class="lineCov">        100 :     if(tot_size&gt;0)</span></a>
<a name="1406"><span class="lineNum">    1406 </span>            :     {</a>
<a name="1407"><span class="lineNum">    1407 </span><span class="lineCov">        100 :       std::vector&lt;int&gt; disp(NumParallel_);</span></a>
<a name="1408"><span class="lineNum">    1408 </span><span class="lineCov">        200 :       for(unsigned r=0; r&lt;NumParallel_-1; r++)</span></a>
<a name="1409"><span class="lineNum">    1409 </span><span class="lineCov">        100 :         disp[r+1]=disp[r]+all_nlist_size[r];</span></a>
<a name="1410"><span class="lineNum">    1410 </span><span class="lineCov">        100 :       std::vector&lt;unsigned&gt; local_nlist_index=nlist_index_;</span></a>
<a name="1411"><span class="lineNum">    1411 </span><span class="lineCov">        100 :       nlist_index_.resize(tot_size);</span></a>
<a name="1412"><span class="lineNum">    1412 </span><span class="lineCov">        100 :       comm.Allgatherv(local_nlist_index,nlist_index_,&amp;all_nlist_size[0],&amp;disp[0]);</span></a>
<a name="1413"><span class="lineNum">    1413 </span><span class="lineCov">        100 :       if(recursive_merge_)</span></a>
<a name="1414"><span class="lineNum">    1414 </span><span class="lineCov">        100 :         std::sort(nlist_index_.begin(),nlist_index_.end());</span></a>
<a name="1415"><span class="lineNum">    1415 </span>            :     }</a>
<a name="1416"><span class="lineNum">    1416 </span>            :   }</a>
<a name="1417"><span class="lineNum">    1417 </span>            :   //calculate the square deviation</a>
<a name="1418"><span class="lineNum">    1418 </span><span class="lineCov">        202 :   std::vector&lt;double&gt; dev2(ncv_,0.);</span></a>
<a name="1419"><span class="lineNum">    1419 </span><span class="lineCov">        670 :   for(unsigned k=rank_; k&lt;nlist_index_.size(); k+=NumParallel_)</span></a>
<a name="1420"><span class="lineNum">    1420 </span>            :   {</a>
<a name="1421"><span class="lineNum">    1421 </span><span class="lineCov">       1404 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1422"><span class="lineNum">    1422 </span>            :     {</a>
<a name="1423"><span class="lineNum">    1423 </span><span class="lineCov">        936 :       const double diff_ik=difference(i,nlist_center_[i],kernels_[nlist_index_[k]].center[i]);</span></a>
<a name="1424"><span class="lineNum">    1424 </span><span class="lineCov">        936 :       dev2[i]+=diff_ik*diff_ik;</span></a>
<a name="1425"><span class="lineNum">    1425 </span>            :     }</a>
<a name="1426"><span class="lineNum">    1426 </span>            :   }</a>
<a name="1427"><span class="lineNum">    1427 </span><span class="lineCov">        202 :   if(NumParallel_&gt;1)</span></a>
<a name="1428"><span class="lineNum">    1428 </span><span class="lineCov">        100 :     comm.Sum(dev2);</span></a>
<a name="1429"><span class="lineNum">    1429 </span><span class="lineCov">        606 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1430"><span class="lineNum">    1430 </span>            :   {</a>
<a name="1431"><span class="lineNum">    1431 </span><span class="lineCov">        404 :     if(dev2[i]==0) //e.g. if nlist_index_.size()==0</span></a>
<a name="1432"><span class="lineNum">    1432 </span><span class="lineCov">         36 :       nlist_dev2_[i]=std::pow(kernels_.back().sigma[i],2);</span></a>
<a name="1433"><span class="lineNum">    1433 </span>            :     else</a>
<a name="1434"><span class="lineNum">    1434 </span><span class="lineCov">        368 :       nlist_dev2_[i]=dev2[i]/nlist_index_.size();</span></a>
<a name="1435"><span class="lineNum">    1435 </span>            :   }</a>
<a name="1436"><span class="lineNum">    1436 </span><span class="lineCov">        202 :   getPntrToComponent(&quot;nlker&quot;)-&gt;set(nlist_index_.size());</span></a>
<a name="1437"><span class="lineNum">    1437 </span><span class="lineCov">        202 :   getPntrToComponent(&quot;nlsteps&quot;)-&gt;set(nlist_steps_);</span></a>
<a name="1438"><span class="lineNum">    1438 </span><span class="lineCov">        202 :   nlist_steps_=0;</span></a>
<a name="1439"><span class="lineNum">    1439 </span><span class="lineCov">        202 :   nlist_update_=false;</span></a>
<a name="1440"><span class="lineNum">    1440 </span>            : }</a>
<a name="1441"><span class="lineNum">    1441 </span>            : </a>
<a name="1442"><span class="lineNum">    1442 </span><span class="lineCov">         10 : void OPESmetad::dumpStateToFile()</span></a>
<a name="1443"><span class="lineNum">    1443 </span>            : {</a>
<a name="1444"><span class="lineNum">    1444 </span>            : //gather adaptive sigma info if needed</a>
<a name="1445"><span class="lineNum">    1445 </span>            : //doing this while writing to file can lead to misterious slowdowns</a>
<a name="1446"><span class="lineNum">    1446 </span>            :   std::vector&lt;double&gt; all_sigma0;</a>
<a name="1447"><span class="lineNum">    1447 </span>            :   std::vector&lt;double&gt; all_av_cv;</a>
<a name="1448"><span class="lineNum">    1448 </span>            :   std::vector&lt;double&gt; all_av_M2;</a>
<a name="1449"><span class="lineNum">    1449 </span><span class="lineCov">         10 :   if(adaptive_sigma_ &amp;&amp; NumWalkers_&gt;1)</span></a>
<a name="1450"><span class="lineNum">    1450 </span>            :   {</a>
<a name="1451"><span class="lineNum">    1451 </span><span class="lineCov">          8 :     all_sigma0.resize(NumWalkers_*ncv_);</span></a>
<a name="1452"><span class="lineNum">    1452 </span><span class="lineCov">          8 :     all_av_cv.resize(NumWalkers_*ncv_);</span></a>
<a name="1453"><span class="lineNum">    1453 </span><span class="lineCov">          8 :     all_av_M2.resize(NumWalkers_*ncv_);</span></a>
<a name="1454"><span class="lineNum">    1454 </span><span class="lineCov">          8 :     if(comm.Get_rank()==0)</span></a>
<a name="1455"><span class="lineNum">    1455 </span>            :     {</a>
<a name="1456"><span class="lineNum">    1456 </span><span class="lineCov">          8 :       multi_sim_comm.Allgather(sigma0_,all_sigma0);</span></a>
<a name="1457"><span class="lineNum">    1457 </span><span class="lineCov">          8 :       multi_sim_comm.Allgather(av_cv_,all_av_cv);</span></a>
<a name="1458"><span class="lineNum">    1458 </span><span class="lineCov">          8 :       multi_sim_comm.Allgather(av_M2_,all_av_M2);</span></a>
<a name="1459"><span class="lineNum">    1459 </span>            :     }</a>
<a name="1460"><span class="lineNum">    1460 </span><span class="lineCov">          8 :     comm.Bcast(all_sigma0,0);</span></a>
<a name="1461"><span class="lineNum">    1461 </span><span class="lineCov">          8 :     comm.Bcast(all_av_cv,0);</span></a>
<a name="1462"><span class="lineNum">    1462 </span><span class="lineCov">          8 :     comm.Bcast(all_av_M2,0);</span></a>
<a name="1463"><span class="lineNum">    1463 </span>            :   }</a>
<a name="1464"><span class="lineNum">    1464 </span>            : </a>
<a name="1465"><span class="lineNum">    1465 </span>            : //rewrite header or rewind file</a>
<a name="1466"><span class="lineNum">    1466 </span><span class="lineCov">         10 :   if(storeOldStates_)</span></a>
<a name="1467"><span class="lineNum">    1467 </span><span class="lineCov">          8 :     stateOfile_.clearFields();</span></a>
<a name="1468"><span class="lineNum">    1468 </span><span class="lineCov">          2 :   else if(walker_rank_==0)</span></a>
<a name="1469"><span class="lineNum">    1469 </span><span class="lineCov">          2 :     stateOfile_.rewind();</span></a>
<a name="1470"><span class="lineNum">    1470 </span>            : //define fields</a>
<a name="1471"><span class="lineNum">    1471 </span><span class="lineCov">         10 :   stateOfile_.addConstantField(&quot;action&quot;);</span></a>
<a name="1472"><span class="lineNum">    1472 </span><span class="lineCov">         10 :   stateOfile_.addConstantField(&quot;biasfactor&quot;);</span></a>
<a name="1473"><span class="lineNum">    1473 </span><span class="lineCov">         10 :   stateOfile_.addConstantField(&quot;epsilon&quot;);</span></a>
<a name="1474"><span class="lineNum">    1474 </span><span class="lineCov">         10 :   stateOfile_.addConstantField(&quot;kernel_cutoff&quot;);</span></a>
<a name="1475"><span class="lineNum">    1475 </span><span class="lineCov">         10 :   stateOfile_.addConstantField(&quot;compression_threshold&quot;);</span></a>
<a name="1476"><span class="lineNum">    1476 </span><span class="lineCov">         10 :   stateOfile_.addConstantField(&quot;zed&quot;);</span></a>
<a name="1477"><span class="lineNum">    1477 </span><span class="lineCov">         10 :   stateOfile_.addConstantField(&quot;sum_weights&quot;);</span></a>
<a name="1478"><span class="lineNum">    1478 </span><span class="lineCov">         10 :   stateOfile_.addConstantField(&quot;sum_weights2&quot;);</span></a>
<a name="1479"><span class="lineNum">    1479 </span><span class="lineCov">         10 :   stateOfile_.addConstantField(&quot;counter&quot;);</span></a>
<a name="1480"><span class="lineNum">    1480 </span><span class="lineCov">         10 :   if(adaptive_sigma_)</span></a>
<a name="1481"><span class="lineNum">    1481 </span>            :   {</a>
<a name="1482"><span class="lineNum">    1482 </span><span class="lineCov">         10 :     stateOfile_.addConstantField(&quot;adaptive_counter&quot;);</span></a>
<a name="1483"><span class="lineNum">    1483 </span><span class="lineCov">         10 :     if(NumWalkers_==1)</span></a>
<a name="1484"><span class="lineNum">    1484 </span>            :     {</a>
<a name="1485"><span class="lineNum">    1485 </span><span class="lineCov">          6 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1486"><span class="lineNum">    1486 </span>            :       {</a>
<a name="1487"><span class="lineNum">    1487 </span><span class="lineCov">          8 :         stateOfile_.addConstantField(&quot;sigma0_&quot;+getPntrToArgument(i)-&gt;getName());</span></a>
<a name="1488"><span class="lineNum">    1488 </span><span class="lineCov">          8 :         stateOfile_.addConstantField(&quot;av_cv_&quot;+getPntrToArgument(i)-&gt;getName());</span></a>
<a name="1489"><span class="lineNum">    1489 </span><span class="lineCov">          8 :         stateOfile_.addConstantField(&quot;av_M2_&quot;+getPntrToArgument(i)-&gt;getName());</span></a>
<a name="1490"><span class="lineNum">    1490 </span>            :       }</a>
<a name="1491"><span class="lineNum">    1491 </span>            :     }</a>
<a name="1492"><span class="lineNum">    1492 </span>            :     else</a>
<a name="1493"><span class="lineNum">    1493 </span>            :     {</a>
<a name="1494"><span class="lineNum">    1494 </span><span class="lineCov">         24 :       for(unsigned w=0; w&lt;NumWalkers_; w++)</span></a>
<a name="1495"><span class="lineNum">    1495 </span><span class="lineCov">         48 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1496"><span class="lineNum">    1496 </span>            :         {</a>
<a name="1497"><span class="lineNum">    1497 </span><span class="lineCov">         64 :           const std::string arg_iw=getPntrToArgument(i)-&gt;getName()+&quot;_&quot;+std::to_string(w);</span></a>
<a name="1498"><span class="lineNum">    1498 </span><span class="lineCov">         32 :           stateOfile_.addConstantField(&quot;sigma0_&quot;+arg_iw);</span></a>
<a name="1499"><span class="lineNum">    1499 </span><span class="lineCov">         32 :           stateOfile_.addConstantField(&quot;av_cv_&quot;+arg_iw);</span></a>
<a name="1500"><span class="lineNum">    1500 </span><span class="lineCov">         64 :           stateOfile_.addConstantField(&quot;av_M2_&quot;+arg_iw);</span></a>
<a name="1501"><span class="lineNum">    1501 </span>            :         }</a>
<a name="1502"><span class="lineNum">    1502 </span>            :     }</a>
<a name="1503"><span class="lineNum">    1503 </span>            :   }</a>
<a name="1504"><span class="lineNum">    1504 </span>            : //print fields</a>
<a name="1505"><span class="lineNum">    1505 </span><span class="lineCov">         30 :   for(unsigned i=0; i&lt;ncv_; i++) //periodicity of CVs</span></a>
<a name="1506"><span class="lineNum">    1506 </span><span class="lineCov">         20 :     stateOfile_.setupPrintValue(getPntrToArgument(i));</span></a>
<a name="1507"><span class="lineNum">    1507 </span><span class="lineCov">         20 :   stateOfile_.printField(&quot;action&quot;,getName()+&quot;_state&quot;);</span></a>
<a name="1508"><span class="lineNum">    1508 </span><span class="lineCov">         10 :   stateOfile_.printField(&quot;biasfactor&quot;,biasfactor_);</span></a>
<a name="1509"><span class="lineNum">    1509 </span><span class="lineCov">         10 :   stateOfile_.printField(&quot;epsilon&quot;,epsilon_);</span></a>
<a name="1510"><span class="lineNum">    1510 </span><span class="lineCov">         10 :   stateOfile_.printField(&quot;kernel_cutoff&quot;,sqrt(cutoff2_));</span></a>
<a name="1511"><span class="lineNum">    1511 </span><span class="lineCov">         10 :   stateOfile_.printField(&quot;compression_threshold&quot;,sqrt(threshold2_));</span></a>
<a name="1512"><span class="lineNum">    1512 </span><span class="lineCov">         10 :   stateOfile_.printField(&quot;zed&quot;,Zed_);</span></a>
<a name="1513"><span class="lineNum">    1513 </span><span class="lineCov">         10 :   stateOfile_.printField(&quot;sum_weights&quot;,sum_weights_);</span></a>
<a name="1514"><span class="lineNum">    1514 </span><span class="lineCov">         10 :   stateOfile_.printField(&quot;sum_weights2&quot;,sum_weights2_);</span></a>
<a name="1515"><span class="lineNum">    1515 </span><span class="lineCov">         10 :   stateOfile_.printField(&quot;counter&quot;,counter_);</span></a>
<a name="1516"><span class="lineNum">    1516 </span><span class="lineCov">         10 :   if(adaptive_sigma_)</span></a>
<a name="1517"><span class="lineNum">    1517 </span>            :   {</a>
<a name="1518"><span class="lineNum">    1518 </span><span class="lineCov">         10 :     stateOfile_.printField(&quot;adaptive_counter&quot;,adaptive_counter_);</span></a>
<a name="1519"><span class="lineNum">    1519 </span><span class="lineCov">         10 :     if(NumWalkers_==1)</span></a>
<a name="1520"><span class="lineNum">    1520 </span>            :     {</a>
<a name="1521"><span class="lineNum">    1521 </span><span class="lineCov">          6 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1522"><span class="lineNum">    1522 </span>            :       {</a>
<a name="1523"><span class="lineNum">    1523 </span><span class="lineCov">          8 :         stateOfile_.printField(&quot;sigma0_&quot;+getPntrToArgument(i)-&gt;getName(),sigma0_[i]);</span></a>
<a name="1524"><span class="lineNum">    1524 </span><span class="lineCov">          8 :         stateOfile_.printField(&quot;av_cv_&quot;+getPntrToArgument(i)-&gt;getName(),av_cv_[i]);</span></a>
<a name="1525"><span class="lineNum">    1525 </span><span class="lineCov">          8 :         stateOfile_.printField(&quot;av_M2_&quot;+getPntrToArgument(i)-&gt;getName(),av_M2_[i]);</span></a>
<a name="1526"><span class="lineNum">    1526 </span>            :       }</a>
<a name="1527"><span class="lineNum">    1527 </span>            :     }</a>
<a name="1528"><span class="lineNum">    1528 </span>            :     else</a>
<a name="1529"><span class="lineNum">    1529 </span>            :     {</a>
<a name="1530"><span class="lineNum">    1530 </span><span class="lineCov">         24 :       for(unsigned w=0; w&lt;NumWalkers_; w++)</span></a>
<a name="1531"><span class="lineNum">    1531 </span><span class="lineCov">         48 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1532"><span class="lineNum">    1532 </span>            :         {</a>
<a name="1533"><span class="lineNum">    1533 </span><span class="lineCov">         64 :           const std::string arg_iw=getPntrToArgument(i)-&gt;getName()+&quot;_&quot;+std::to_string(w);</span></a>
<a name="1534"><span class="lineNum">    1534 </span><span class="lineCov">         32 :           stateOfile_.printField(&quot;sigma0_&quot;+arg_iw,all_sigma0[w*ncv_+i]);</span></a>
<a name="1535"><span class="lineNum">    1535 </span><span class="lineCov">         32 :           stateOfile_.printField(&quot;av_cv_&quot;+arg_iw,all_av_cv[w*ncv_+i]);</span></a>
<a name="1536"><span class="lineNum">    1536 </span><span class="lineCov">         64 :           stateOfile_.printField(&quot;av_M2_&quot;+arg_iw,all_av_M2[w*ncv_+i]);</span></a>
<a name="1537"><span class="lineNum">    1537 </span>            :         }</a>
<a name="1538"><span class="lineNum">    1538 </span>            :     }</a>
<a name="1539"><span class="lineNum">    1539 </span>            :   }</a>
<a name="1540"><span class="lineNum">    1540 </span>            : //print kernels</a>
<a name="1541"><span class="lineNum">    1541 </span><span class="lineCov">         60 :   for(unsigned k=0; k&lt;kernels_.size(); k++)</span></a>
<a name="1542"><span class="lineNum">    1542 </span>            :   {</a>
<a name="1543"><span class="lineNum">    1543 </span><span class="lineCov">        100 :     stateOfile_.printField(&quot;time&quot;,getTime()); //this is not very usefull</span></a>
<a name="1544"><span class="lineNum">    1544 </span><span class="lineCov">        150 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1545"><span class="lineNum">    1545 </span><span class="lineCov">        100 :       stateOfile_.printField(getPntrToArgument(i),kernels_[k].center[i]);</span></a>
<a name="1546"><span class="lineNum">    1546 </span><span class="lineCov">        150 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1547"><span class="lineNum">    1547 </span><span class="lineCov">        200 :       stateOfile_.printField(&quot;sigma_&quot;+getPntrToArgument(i)-&gt;getName(),kernels_[k].sigma[i]);</span></a>
<a name="1548"><span class="lineNum">    1548 </span><span class="lineCov">         50 :     stateOfile_.printField(&quot;height&quot;,kernels_[k].height);</span></a>
<a name="1549"><span class="lineNum">    1549 </span><span class="lineCov">         50 :     stateOfile_.printField();</span></a>
<a name="1550"><span class="lineNum">    1550 </span>            :   }</a>
<a name="1551"><span class="lineNum">    1551 </span>            : //make sure file is written even if small</a>
<a name="1552"><span class="lineNum">    1552 </span><span class="lineCov">         10 :   if(!storeOldStates_)</span></a>
<a name="1553"><span class="lineNum">    1553 </span><span class="lineCov">          2 :     stateOfile_.flush();</span></a>
<a name="1554"><span class="lineNum">    1554 </span><span class="lineCov">         10 : }</span></a>
<a name="1555"><span class="lineNum">    1555 </span>            : </a>
<a name="1556"><span class="lineNum">    1556 </span><span class="lineCov">       5417 : double OPESmetad::evaluateKernel(const kernel&amp; G,const std::vector&lt;double&gt;&amp; x) const</span></a>
<a name="1557"><span class="lineNum">    1557 </span>            : { //NB: cannot be a method of kernel class, because uses external variables (for cutoff)</a>
<a name="1558"><span class="lineNum">    1558 </span>            :   double norm2=0;</a>
<a name="1559"><span class="lineNum">    1559 </span><span class="lineCov">      12827 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1560"><span class="lineNum">    1560 </span>            :   {</a>
<a name="1561"><span class="lineNum">    1561 </span><span class="lineCov">       9517 :     const double dist_i=difference(i,G.center[i],x[i])/G.sigma[i];</span></a>
<a name="1562"><span class="lineNum">    1562 </span><span class="lineCov">       9517 :     norm2+=dist_i*dist_i;</span></a>
<a name="1563"><span class="lineNum">    1563 </span><span class="lineCov">       9517 :     if(norm2&gt;=cutoff2_)</span></a>
<a name="1564"><span class="lineNum">    1564 </span>            :       return 0;</a>
<a name="1565"><span class="lineNum">    1565 </span>            :   }</a>
<a name="1566"><span class="lineNum">    1566 </span><span class="lineCov">       3310 :   return G.height*(std::exp(-0.5*norm2)-val_at_cutoff_);</span></a>
<a name="1567"><span class="lineNum">    1567 </span>            : }</a>
<a name="1568"><span class="lineNum">    1568 </span>            : </a>
<a name="1569"><span class="lineNum">    1569 </span><span class="lineCov">       2981 : double OPESmetad::evaluateKernel(const kernel&amp; G,const std::vector&lt;double&gt;&amp; x, std::vector&lt;double&gt;&amp; acc_der, std::vector&lt;double&gt;&amp; dist)</span></a>
<a name="1570"><span class="lineNum">    1570 </span>            : { //NB: cannot be a method of kernel class, because uses external variables (for cutoff)</a>
<a name="1571"><span class="lineNum">    1571 </span>            :   double norm2=0;</a>
<a name="1572"><span class="lineNum">    1572 </span><span class="lineCov">       6091 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1573"><span class="lineNum">    1573 </span>            :   {</a>
<a name="1574"><span class="lineNum">    1574 </span><span class="lineCov">       4814 :     dist[i]=difference(i,G.center[i],x[i])/G.sigma[i];</span></a>
<a name="1575"><span class="lineNum">    1575 </span><span class="lineCov">       4814 :     norm2+=dist[i]*dist[i];</span></a>
<a name="1576"><span class="lineNum">    1576 </span><span class="lineCov">       4814 :     if(norm2&gt;=cutoff2_)</span></a>
<a name="1577"><span class="lineNum">    1577 </span>            :       return 0;</a>
<a name="1578"><span class="lineNum">    1578 </span>            :   }</a>
<a name="1579"><span class="lineNum">    1579 </span><span class="lineCov">       1277 :   const double val=G.height*(std::exp(-0.5*norm2)-val_at_cutoff_);</span></a>
<a name="1580"><span class="lineNum">    1580 </span><span class="lineCov">       3831 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1581"><span class="lineNum">    1581 </span><span class="lineCov">       2554 :     acc_der[i]-=dist[i]/G.sigma[i]*val; //NB: we accumulate the derivative into der</span></a>
<a name="1582"><span class="lineNum">    1582 </span>            :   return val;</a>
<a name="1583"><span class="lineNum">    1583 </span>            : }</a>
<a name="1584"><span class="lineNum">    1584 </span>            : </a>
<a name="1585"><span class="lineNum">    1585 </span><span class="lineCov">        282 : void OPESmetad::mergeKernels(kernel&amp; k1,const kernel&amp; k2)</span></a>
<a name="1586"><span class="lineNum">    1586 </span>            : {</a>
<a name="1587"><span class="lineNum">    1587 </span><span class="lineCov">        282 :   const double h=k1.height+k2.height;</span></a>
<a name="1588"><span class="lineNum">    1588 </span><span class="lineCov">        846 :   for(unsigned i=0; i&lt;k1.center.size(); i++)</span></a>
<a name="1589"><span class="lineNum">    1589 </span>            :   {</a>
<a name="1590"><span class="lineNum">    1590 </span><span class="lineCov">        564 :     const bool isPeriodic_i=getPntrToArgument(i)-&gt;isPeriodic();</span></a>
<a name="1591"><span class="lineNum">    1591 </span><span class="lineCov">        564 :     if(isPeriodic_i)</span></a>
<a name="1592"><span class="lineNum">    1592 </span><span class="lineCov">        564 :       k1.center[i]=k2.center[i]+difference(i,k2.center[i],k1.center[i]); //fix PBC</span></a>
<a name="1593"><span class="lineNum">    1593 </span><span class="lineCov">        564 :     const double c_i=(k1.height*k1.center[i]+k2.height*k2.center[i])/h;</span></a>
<a name="1594"><span class="lineNum">    1594 </span><span class="lineCov">        564 :     const double ss_k1_part=k1.height*(k1.sigma[i]*k1.sigma[i]+k1.center[i]*k1.center[i]);</span></a>
<a name="1595"><span class="lineNum">    1595 </span><span class="lineCov">        564 :     const double ss_k2_part=k2.height*(k2.sigma[i]*k2.sigma[i]+k2.center[i]*k2.center[i]);</span></a>
<a name="1596"><span class="lineNum">    1596 </span><span class="lineCov">        564 :     const double ss_i=(ss_k1_part+ss_k2_part)/h-c_i*c_i;</span></a>
<a name="1597"><span class="lineNum">    1597 </span><span class="lineCov">        564 :     if(isPeriodic_i)</span></a>
<a name="1598"><span class="lineNum">    1598 </span><span class="lineCov">        564 :       k1.center[i]=bringBackInPbc(i,c_i);</span></a>
<a name="1599"><span class="lineNum">    1599 </span>            :     else</a>
<a name="1600"><span class="lineNum">    1600 </span><span class="lineNoCov">          0 :       k1.center[i]=c_i;</span></a>
<a name="1601"><span class="lineNum">    1601 </span><span class="lineCov">        564 :     k1.sigma[i]=sqrt(ss_i);</span></a>
<a name="1602"><span class="lineNum">    1602 </span>            :   }</a>
<a name="1603"><span class="lineNum">    1603 </span><span class="lineCov">        282 :   k1.height=h;</span></a>
<a name="1604"><span class="lineNum">    1604 </span><span class="lineCov">        282 : }</span></a>
<a name="1605"><span class="lineNum">    1605 </span>            : </a>
<a name="1606"><span class="lineNum">    1606 </span>            : }</a>
<a name="1607"><span class="lineNum">    1607 </span>            : }</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.15</a></td></tr>
  </table>
  <br>

</body>
</html>
